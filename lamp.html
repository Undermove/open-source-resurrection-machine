<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Gas Discharge Lamp Prototype</title>
  <style>
    :root{
      --bg0:#07070b;
      --bg1:#0d0d16;
      --panel:#121220cc;
      --panel2:#151528e6;
      --stroke:rgba(255,255,255,.12);
      --text:#e9e9f3;
      --muted:rgba(233,233,243,.7);
      --accent:#7cd1ff;
    }
    html, body{ margin:0; height:100%; background: radial-gradient(circle at 50% 20%, var(--bg1) 0%, var(--bg0) 70%); color:var(--text);
      font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif;
      overflow:hidden;
    }
    #app{ position:fixed; inset:0; display:grid; grid-template-columns: 360px 1fr; gap: 14px; padding: 14px; box-sizing:border-box; }
    @media (max-width: 920px){
      #app{ grid-template-columns: 1fr; grid-template-rows:auto 1fr; }
    }

    .panel{ background: var(--panel); border:1px solid var(--stroke); border-radius:14px; box-shadow: 0 14px 45px rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
    }

    #controls{ padding: 14px; display:flex; flex-direction:column; gap:12px; }
    #controls h1{ margin: 4px 0 2px; font-size: 16px; letter-spacing: .2px; }
    #controls .sub{ margin: 0 0 6px; font-size: 12px; color: var(--muted); line-height:1.35; }

    .grid{ display:grid; grid-template-columns: 1fr; gap: 10px; }
    .row{ display:grid; grid-template-columns: 1fr auto; align-items:center; gap: 10px; }
    .row label{ font-size: 12px; color: var(--muted); }
    .row output{ font-variant-numeric: tabular-nums; font-size: 12px; color: rgba(255,255,255,.88); }

    select, input[type="range"], button{
      width:100%;
      box-sizing:border-box;
      font: inherit;
    }

    input[type="number"]{
      width:100%;
      box-sizing:border-box;
      margin-top: 6px;
      padding: 8px 10px;
      border-radius: 10px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      color: var(--text);
      outline: none;
      font-size: 12px;
      font-variant-numeric: tabular-nums;
    }
    input[type="number"]:focus-visible{ outline: 2px dashed var(--accent); outline-offset: 2px; }

    select{
      background: rgba(255,255,255,.05);
      border:1px solid var(--stroke);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 10px;
      outline:none;
    }
    select:focus-visible{ outline: 2px dashed var(--accent); outline-offset: 2px; }

    input[type="range"]{ accent-color: var(--accent); }

    .btnrow{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    button{
      border-radius: 12px;
      padding: 10px 12px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
      cursor:pointer;
      font-weight: 650;
    }
    button:hover{ background: rgba(255,255,255,.10); }
    button:active{ transform: translateY(1px); }
    button:focus-visible{ outline: 2px dashed var(--accent); outline-offset: 2px; }

    #sim{ position:relative; overflow:hidden; display:flex; flex-direction:column; }
    #canvasWrap{ position:relative; flex: 1 1 auto; min-height: 320px; }
    #view{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    #hud{
      position:absolute; left: 14px; top: 12px; right: 14px;
      display:flex; gap: 10px; flex-wrap:wrap; align-items:center;
      pointer-events:none;
    }
    .chip{
      pointer-events:none;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: rgba(255,255,255,.88);
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
      font-variant-numeric: tabular-nums;
    }
    .chip b{ color:#fff; font-weight:750; }

    #footerHint{
      position:absolute; left:14px; bottom:12px; right:14px;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      pointer-events:none;
      color: rgba(255,255,255,.55);
      font-size: 12px;
    }

    #boom{
      position:absolute; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
    }
    #boom.show{ display:flex; }
    #boom .card{
      max-width: 560px;
      width: 100%;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      background: rgba(10,10,18,.78);
      box-shadow: 0 18px 70px rgba(0,0,0,.65);
      padding: 14px 14px;
    }
    #boom h3{
      margin: 6px 0 8px;
      font-size: 18px;
      color: rgba(255,255,255,.92);
    }
    #boom p{
      margin: 0 0 12px;
      color: rgba(255,255,255,.80);
      font-size: 15px;
      line-height: 1.6;
    }
    #boom .row{
      display:flex;
      gap: 10px;
      justify-content:flex-end;
    }

    #math{
      flex: 0 0 auto;
      border-top: 1px solid var(--stroke);
      background:
        radial-gradient(1200px 420px at 20% 0%, rgba(124,209,255,0.10), rgba(0,0,0,0) 55%),
        rgba(0,0,0,0.20);
      padding: 14px 14px;
      max-height: 42%;
      overflow:auto;
    }
    #math .content{ max-width: 900px; margin: 0 auto; }
    #math h2{ margin: 2px 0 12px; font-size: 22px; letter-spacing: .2px; line-height: 1.22; }
    #math h3{ margin: 22px 0 12px; font-size: 18px; color: rgba(255,255,255,.92); }
    #math h4{ margin: 14px 0 10px; font-size: 16px; color: rgba(255,255,255,.90); }
    #math p{ margin: 12px 0; color: rgba(255,255,255,.82); font-size: 16px; line-height: 1.7; }
    #math .eq{
      font-family: inherit;
      font-size: 15px;
      color: rgba(255,255,255,.86);
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 12px 12px;
      overflow:auto;
      line-height: 1.65;
    }
    #math .eq p{ margin: 10px 0; }
    #math .eq .k{ color: rgba(255,255,255,.86); font-weight: 650; }
    #math .eq .k{ display:block; margin: 8px 0 10px; }
    #math .eq .k:first-child{ margin-top: 0; }
    #math .eq math{ margin: 18px 0; }
    #math .eq math,
    #math .eq .mono,
    #math .eq .v{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #math math{ font-size: 19px; }
    #math math mi{ font-style: italic; }
    #math .k{ color: rgba(255,255,255,.6); }
    #math .v{ color: rgba(255,255,255,.95); }
    #math .lead{ color: rgba(255,255,255,.82); }
    #math .callout{ margin-top: 12px; padding: 12px 14px; border-radius: 14px; border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(124,209,255,0.10), rgba(255,255,255,0.03));
      color: rgba(255,255,255,.80);
      font-size: 16px;
      line-height: 1.68;
    }
    #math .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 920px){
      #math .grid2{ grid-template-columns: 1fr; }
    }
    #math .bul{ margin: 10px 0 12px; padding-left: 20px; }
    #math .bul li{ margin: 8px 0; color: rgba(255,255,255,.78); font-size: 16px; line-height: 1.68; }

    #math .step{ border-left: 2px solid rgba(124,209,255,0.35); padding-left: 10px; margin: 14px 0; }
    #math .badge{ display:inline-block; font-size: 13px; padding: 3px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.85);
    }

    .lens{
      position:absolute;
      right: 6px;
      top: 18px;
      width: 180px;
      height: 180px;
      pointer-events:none;
      filter: drop-shadow(0 14px 30px rgba(0,0,0,.65));
      opacity: 0.95;
    }
    .lens .cap{ position:absolute; inset:0; border-radius: 50%; border: 2px solid rgba(255,255,255,0.18);
      box-shadow: inset 0 0 22px rgba(0,0,0,.45);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.10), rgba(0,0,0,0.10) 55%, rgba(0,0,0,0.18));
    }
    .lens .lbl{ position:absolute; left: 10px; right: 10px; bottom: 10px; text-align:center; font-size: 12px; color: rgba(255,255,255,.72);
      text-shadow: 0 1px 0 rgba(0,0,0,.55);
    }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div id="app">
    <section id="controls" class="panel">
      <h1>Симуляция зажигания газоразрядной лампы</h1>
      <p class="sub">Упрощённая физика: порог пробоя по закону Пашена + режим тления после пробоя. Источник питания в этой модели — <span class="mono">постоянного напряжения (DC)</span>. Параметры газа — приблизительные, но поведение правдоподобное.</p>

      <div class="grid">
        <div>
          <div class="row">
            <label for="gas">Газ</label>
            <output id="gasOut">Ne</output>
          </div>
          <select id="gas">
            <option value="neon" selected>Неон (Ne)</option>
            <option value="argon">Аргон (Ar)</option>
            <option value="helium">Гелий (He)</option>
            <option value="nitrogen">Азот (N₂)</option>
            <option value="mercury">Пары ртути (Hg) + Ar</option>
          </select>
        </div>

        <div>
          <div class="row">
            <label for="voltage">Напряжение V (кВ)</label>
            <output id="voltageOut" class="mono">2.00 кВ</output>
          </div>
          <input id="voltage" type="range" min="0" max="20000" value="2000" step="10" />
          <input id="voltageNum" type="number" min="0" max="20" step="0.01" value="2.00" />
        </div>

        <div>
          <div class="row">
            <label for="pressure">Давление p (мбар)</label>
            <output id="pressureOut" class="mono">20.0 мбар</output>
          </div>
          <input id="pressure" type="range" min="1" max="200" value="20" step="0.1" />
          <input id="pressureNum" type="number" min="1" max="200" step="0.1" value="20.0" />
        </div>

        <div>
          <div class="row">
            <label for="gap">Промежуток между электродами d (см)</label>
            <output id="gapOut" class="mono">25.0 см</output>
          </div>
          <input id="gap" type="range" min="2" max="60" value="25" step="0.1" />
          <input id="gapNum" type="number" min="2" max="60" step="0.1" value="25.0" />
        </div>

        <div>
          <div class="row">
            <label for="ballast">Балласт R (кОм)</label>
            <output id="ballastOut" class="mono">50.0 кОм</output>
          </div>
          <input id="ballast" type="range" min="1" max="200" value="50" step="1" />
          <input id="ballastNum" type="number" min="1" max="200" step="1" value="50" />
        </div>

        <div>
          <div class="row">
            <label for="electrode">Электроды (нагрев) (ε)</label>
            <output id="electrodeOut" class="mono">0.35</output>
          </div>
          <input id="electrode" type="range" min="0" max="1" value="0.35" step="0.01" />
          <input id="electrodeNum" type="number" min="0" max="1" step="0.01" value="0.35" />
        </div>

        <div class="btnrow">
          <button id="toggle" type="button">Включить</button>
          <button id="reset" type="button">Сброс</button>
        </div>
      </div>
    </section>

    <section id="sim" class="panel">
      <div id="canvasWrap">
        <canvas id="view"></canvas>
        <div class="lens" aria-hidden="true">
          <div class="cap"></div>
          <div class="lbl"><span class="mono" id="lensLbl">столкновения: 0.00</span></div>
        </div>
        <div id="boom" role="alert" aria-live="assertive">
          <div class="card">
            <h3>Авария</h3>
            <p id="boomText">Лампа взорвалась из-за слишком большого тока – попробуй отрегулировать Балласт и давление</p>
            <div class="row">
              <button id="boomReset" type="button">Сбросить</button>
            </div>
          </div>
        </div>
        <div id="hud">
          <div class="chip"><b>V<sub>b</sub></b>: <span id="vb" class="mono">—</span></div>
          <div class="chip"><b>Состояние</b>: <span id="mode">выкл</span></div>
          <div class="chip"><b>I</b>: <span id="i" class="mono">0.00 мА</span></div>
          <div class="chip"><b>E/p</b>: <span id="ep" class="mono">—</span></div>
        </div>
        <div id="footerHint">
          <div>Подсказка: для начала просто включи лампу и попробуй поиграться с напряжением.</div>
          <div class="mono">Paschen + glow discharge (prototype)</div>
        </div>
      </div>

      <div id="math" aria-label="Formulas">
        <div class="content">
        <h2>Мини‑учебник: как зажигается газоразрядная лампа</h2>
        
        <h3>Первый опыт: попробуй зажечь лампу! <span style="font-weight:600; color: rgba(255,255,255,.78);">(<a href="#lab1" style="color: inherit; text-decoration: underline;">подсказка, как это сделать — тут</a>)</span></h3>
        <p>Сверху — <span class="mono">лампа</span>: стеклянная трубка с газом и двумя электродами на концах. Кажется, она «просто стекляшка»… пока ты не подашь достаточно большое напряжение.</p>
        <p>Тут есть четыре ручки, с которыми ты будешь играть как настоящий экспериментатор:</p>
        <ul class="bul">
          <li><span class="mono">V</span> — напряжение источника (DC)</li>
          <li><span class="mono">p</span> — давление газа</li>
          <li><span class="mono">d</span> — расстояние между электродами (межэлектродный промежуток)</li>
          <li><span class="mono">R</span> — балласт (он ограничивает ток после зажигания)</li>
        </ul>

        <p>Нажми <span class="mono">«Включить»</span> и поднимай <span class="mono">V</span>. Цель — поймать момент, когда внутри вспыхнет разряд: маленькая «молния в пробирке».</p>

        <p>В правом верхнем углу есть <span class="mono">увеличительное стекло</span> — это иллюстрация микромира внутри газа:</p>
        <ul class="bul">
          <li>«крестики» — электроны</li>
          <li>точки — атомы/молекулы газа</li>
          <li>вспышки — возбуждения атомов, после которых появляется свет</li>
        </ul>

        <div class="callout">
          <div class="lead">Важно: это учебная модель</div>
          <ul class="bul">
            <li>Она показывает главную идею: как происходит <span class="mono">зажигание (пробой) → тлеющий разряд</span> и какие ручки на это влияют.</li>
            <li>Это не «настоящая плазменная физика» со спектрами, распределением энергий электронов и т.д.</li>
            <li>Диаметр трубки здесь <span class="mono">не учитывается</span>: в реальности он влияет на токовую плотность, нагрев и устойчивость разряда, но в этой игрушке считаем его «постоянным».</li>
          </ul>
        </div>

        <h3>Как узнать: загорится лампа или нет? Формула Пашена</h3>
        <div class="eq">
          <p>Посмотри в правый верхний угол симуляции: там есть <span class="mono">Vb</span> — <span class="mono">напряжение пробоя</span>.</p>
          <p>Если подать <span class="mono">V ≥ Vb</span>, газ внезапно перестаёт быть изолятором — и внутри появляется разряд. А дальше начинается магия: разряд может <span class="mono">сохраняться</span> даже при чуть меньшем напряжении (это гистерезис: «зажечь» труднее, чем «держать»).</p>
          <p>Само <span class="mono">Vb</span> — не случайное число. Оно зависит от газа, давления и расстояния между электродами и в простом приближении описывается законом Пашена:</p>

          <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow>
              <msub><mi>V</mi><mi>b</mi></msub>
              <mo>=</mo>
              <mfrac>
                <mrow><mi>B</mi><mo>·</mo><mi>p</mi><mo>·</mo><mi>d</mi></mrow>
                <mrow>
                  <mi>ln</mi><mo>(</mo><mi>A</mi><mo>·</mo><mi>p</mi><mo>·</mo><mi>d</mi><mo>)</mo>
                  <mo>−</mo>
                  <mi>ln</mi><mo>(</mo><mi>ln</mi><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>γ</mi></mfrac><mo>)</mo><mo>)</mo>
                </mrow>
              </mfrac>
            </mrow>
          </math>
          <div class="k">Единицы в этой формуле: p — Па, d — м.</div>
          <div class="k">Что означает каждый символ (простыми словами):</div>
          <ul class="bul">
            <li><span class="mono">p</span> — давление газа <span class="mono">(Па)</span>. В симуляции ты задаёшь давление ползунком <span class="mono">p</span> (в интерфейсе оно показано в мбар, а в формуле автоматически переводится в Па).</li>
            <li><span class="mono">d</span> — расстояние между электродами <span class="mono">(м)</span>. В симуляции ты задаёшь его ползунком <span class="mono">d</span> (в интерфейсе — в см, а в формуле переводится в м).</li>
            <li><span class="mono">Vb</span> — напряжение пробоя: если <span class="mono">V ≥ Vb</span>, лампа может загореться.</li>
          </ul>
          <div class="k">Параметры, которые ты <span class="mono">не задаёшь вручную</span> (они зависят от газа и электродов):</div>
          <ul class="bul">
            <li><span class="mono">A</span> и <span class="mono">B</span> — табличные параметры газа в приближённой форме закона Пашена (условно: «насколько легко газ ионизуется» при данных <span class="mono">p·d</span>).</li>
            <li><span class="mono">γ</span> (гамма) — коэффициент вторичной эмиссии катода: насколько легко катод отдаёт электроны после ударов ионов/фотонов (безразмерно). В реальности <span class="mono">γ</span> зависит от материала и состояния поверхности.</li>
          </ul>
          <div class="k">Откуда берутся <span class="mono">A</span>, <span class="mono">B</span> и <span class="mono">γ</span>:</div>
          <p>В реальной инженерии их берут из справочных данных по разрядам (таблицы/кривые Пашена для газов и материалов электродов) и уточняют экспериментом. В этом прототипе значения — <span class="mono">ориентировочные</span> и подобраны так, чтобы поведение было правдоподобным и удобным для обучения.</p>
          <div style="height:10px"></div>
          <div><span class="k">A</span>=<span class="v" id="mA">—</span>, <span class="k">B</span>=<span class="v" id="mB">—</span>, <span class="k">γ</span>=<span class="v" id="mgamma">—</span></div>
          <div><span class="k">p</span>=<span class="v" id="mp_torr">—</span> Па<span id="mp_mbar" style="display:none">—</span></div>
          <div><span class="k">d</span>=<span class="v" id="md_m">—</span> м<span id="md_cm" style="display:none">—</span></div>
          <div><span class="k">p·d</span>=<span class="v" id="mpd">—</span> Па·м</div>
          <div style="height:10px"></div>
          <div>ln(A·p·d) = ln(<span class="v" id="mApd">—</span>) = <span class="v" id="mlnApd">—</span></div>
          <div>ln(ln(1+1/γ)) = ln(ln(<span class="v" id="m1g">—</span>)) = <span class="v" id="mlnln">—</span></div>
          <div>denom = <span class="v" id="mden">—</span></div>
          <div style="height:10px"></div>
          <div><span class="k">Vb</span> ≈ <span class="v" id="mVb">—</span> В = <span class="v" id="mVb_kv">—</span> кВ</div>
        </div>

        <div class="step">
          <div class="badge">Правило</div>
          <p>Если ты увеличиваешь <span class="mono">p</span> или <span class="mono">d</span>, обычно растёт <span class="mono">Vb</span> — и лампу труднее зажечь. Если уменьшаешь — зажечь легче.</p>
          <p>Но есть тонкость: закон Пашена даёт «кривую» с минимумом. Это значит, что для каждого газа есть область <span class="mono">p·d</span>, где зажигается легче всего — а слишком маленькое и слишком большое <span class="mono">p·d</span> могут снова повышать <span class="mono">Vb</span>.</p>
        </div>

        <h3 id="lab1">Мини‑лабораторная 1: зажигаем неон (Ne)</h3>
        <div class="step">
          <div class="badge">Шаг 1</div>
          <p>Выбери <span class="mono">Неон (Ne)</span>. Поставь, например: <span class="mono">p=5 мбар</span>, <span class="mono">d=10 см</span>, <span class="mono">R=50 кОм</span>. Нажми <span class="mono">«Включить»</span>.</p>
        </div>
        <div class="step">
          <div class="badge">Шаг 2</div>
          <p>Поднимай <span class="mono">V</span>, пока не станет <span class="mono">V ≥ Vb</span> (смотри плашку <span class="mono">Vb</span> и «Состояние» сверху).</p>
        </div>
        <div class="step">
          <div class="badge">Что происходит внутри (очень просто)</div>
          <ul class="bul">
            <li>Электроны разгоняются электрическим полем.</li>
            <li>При столкновениях они возбуждают атомы неона (в лупе это вспышки).</li>
            <li>Возбуждённые атомы «сбрасывают» энергию в виде света — поэтому трубка начинает светиться.</li>
          </ul>
          <p>Фишка: если после зажигания немного уменьшить <span class="mono">V</span>, лампа может продолжать светиться. Это нормальный <span class="mono">гистерезис</span>: напряжение поддержания обычно ниже напряжения пробоя.</p>
        </div>

        <div class="step">
          <div class="badge">Осторожно: лампа может «взорваться»</div>
          <p>Если после пробоя ток станет слишком большим, в симуляции сработает авария: появится <span class="mono">OVER</span> и лампа «взорвётся». Это просто наглядная подсказка: в реальности большой ток быстро перегревает электроды и разрушает разрядник.</p>
          <p>Чтобы этого не случилось, увеличь <span class="mono">R</span> (балласт): он ограничивает ток по простой идее <span class="mono">I ≈ (V − Vplasma) / R</span>. Чем больше <span class="mono">R</span>, тем безопаснее режим.</p>
        </div>

        <h3>Мини‑лабораторная 2: попробуй «пары ртути (Hg) + Ar»</h3>
        <div class="step">
          <div class="badge">Задание</div>
          <p>Переключись на <span class="mono">Пары ртути (Hg) + Ar</span> и попробуй зажечь лампу так же, как с неоном.</p>
          <ul class="bul">
            <li>Подбери <span class="mono">p</span> и <span class="mono">d</span>, чтобы <span class="mono">Vb</span> оказался достижим при твоём <span class="mono">V</span>.</li>
            <li>После зажигания подбери <span class="mono">R</span>, чтобы ток был «разумным» (слишком большой ток в реальности быстро убивает электроды).</li>
          </ul>
          <p>Подсказка: в реальных ртутных лампах основное излучение идёт в УФ, а видимый свет часто получают через люминофор.</p>
        </div>

        <h3>После пробоя: откуда берётся свет (и почему он разного цвета)</h3>
        <div class="grid2">
          <div class="eq">
            <div class="k">Откуда берётся свет (Ne/Ar/He/N₂)</div>
            <div style="height:6px"></div>
            <div>e⁻ + Atom → Atom* + e⁻</div>
            <div>Atom* → Atom + hν</div>
            <div style="height:6px"></div>
            <div class="k">Смысл:</div>
            <p>электрон разгоняется электрическим полем, сталкивается с атомом и «подбрасывает» его на более высокий энергетический уровень (это Atom*).</p>
            <p>потом атом почти сразу «падает обратно» и излучает фотон <span class="mono">hν</span>. Набор возможных переходов задаёт <span class="mono">спектральные линии</span> газа — отсюда и цвет (неон — красно‑оранжевый, аргон — фиолетово‑синий и т.д.).</p>
            <p>Важно: в инертных газах значительная часть излучения как раз попадает в видимый диапазон, поэтому лампа светится «сама по себе», без люминофора.</p>
          </div>
          <div class="eq">
            <div class="k">Ртутная/люминесцентная (Hg + инертный газ)</div>
            <div style="height:6px"></div>
            <div>e⁻ + Hg → Hg* + e⁻</div>
            <div>Hg* → Hg + hν<sub>UV</sub></div>
            <div>phosphor + hν<sub>UV</sub> → light (visible)</div>
            <div style="height:6px"></div>
            <div class="k">Смысл:</div>
            <p>ртуть тоже возбуждается ударами электронов, но её самые «мощные» линии часто в ультрафиолете — глаз их почти не видит.</p>
            <p>поэтому внутри колбы есть слой <span class="mono">люминофора</span>. Он поглощает УФ‑фотон, внутри люминофора энергия на мгновение превращается в возбуждение кристалла, а затем люминофор испускает <span class="mono">новый фотон</span> уже в видимом диапазоне.</p>
            <p>От состава люминофора зависит оттенок (тёплый/холодный) и эффективность.</p>
          </div>
        </div>

        <h3>Что «делает» разряд ярче: поле и ток</h3>
        <div class="eq">
          <div class="k">Формулы:</div>
          <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow>
              <mi>E</mi><mo>≈</mo><mfrac><mi>V</mi><mi>d</mi></mfrac>
              <mspace width="14px"/>
              <mfrac><mi>E</mi><mi>p</mi></mfrac><mo>≈</mo><mfrac><mrow><mi>V</mi><mo>/</mo><mi>d</mi></mrow><mi>p</mi></mfrac>
            </mrow>
          </math>
          <div style="height:8px"></div>
          <div><span class="k">V</span>=<span class="v" id="mV">—</span> В, <span class="k">d</span>=<span class="v" id="md2">—</span> м → <span class="k">E</span>=<span class="v" id="mE">—</span> В/м</div>
          <div><span class="k">p</span>=<span class="v" id="mp2">—</span> Па → <span class="k">E/p</span>=<span class="v" id="mEp">—</span> В/(м·Па)</div>
        </div>

        <h3>Почему нужен балласт (R): иначе разряд «убежит» в большой ток</h3>
        <div class="eq">
          <p>Ключевая мысль: после пробоя газ перестаёт быть «сопротивлением», которое само ограничивает ток. Если дать ему волю — ток начнёт расти.</p>
          <p>Балласт <span class="mono">R</span> — это твой «ограничитель»: он берёт лишнее напряжение на себя и задаёт ток.</p>
          <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow>
              <mi>I</mi><mo>≈</mo><mfrac><mrow><mi>max</mi><mo>(</mo><mn>0</mn><mo>,</mo><mi>V</mi><mo>−</mo><msub><mi>V</mi><mi>plasma</mi></msub><mo>)</mo></mrow><mi>R</mi></mfrac>
            </mrow>
          </math>
          <p>В прототипе Vplasma — упрощённое «падение на плазме» (порядка сотен вольт), зависящее от газа и режима.</p>
          <div style="height:8px"></div>
          <div><span class="k">R</span>=<span class="v" id="mR">—</span> Ом, <span class="k">Vplasma</span>≈<span class="v" id="mVp">—</span> В → <span class="k">I</span>≈<span class="v" id="mI">—</span> мА</div>
        </div>

        <h3>С какими проблемами сталкиваются реальные производители (и что оптимизируют)</h3>
        <p>В реальном мире «просто зажечь» — это только начало. Инженерам нужно сделать так, чтобы лампа запускалась <span class="mono">всегда</span>, светила <span class="mono">ярко</span> и при этом жила <span class="mono">долго</span>.</p>
        <div class="eq">
          <div class="k">Типичный компромисс (упрощённо):</div>
          <div style="height:6px"></div>
          <div><span class="k">Минимизировать</span> V_start(p,d,gas,γ,электроды) и потери P_electrodes</div>
          <div><span class="k">Максимизировать</span> luminous_efficacy (lm/W) и lifetime</div>
          <div style="height:6px"></div>
          <div class="k">При ограничениях:</div>
          <ul class="bul">
            <li>напряжение источника ограничено (сеть/инвертор/балласт)</li>
            <li>ток и температура электродов ограничены (иначе распыление и быстрый износ)</li>
            <li>газ и давление подбирают так, чтобы разряд был устойчивым и эффективным (и чтобы спектр был «правильным»)</li>
          </ul>
        </div>
        <p>На практике это похоже на настройку музыкального инструмента: чуть меняешь <span class="mono">p</span> или <span class="mono">d</span> — и меняется запуск, устойчивость и режим. Чуть меняешь <span class="mono">R</span> — и у тебя уже другой ток, другая яркость и другая «судьба» электродов.</p>
        <p>Текущая оценка «яркости» (ориентир для игры): <span class="mono" id="mBright">—</span></p>

        </div>
      </div>
    </section>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d', { alpha: true });

    const canvasWrap = document.getElementById('canvasWrap');

    const el = {
      gas: document.getElementById('gas'),
      gasOut: document.getElementById('gasOut'),
      voltage: document.getElementById('voltage'),
      voltageOut: document.getElementById('voltageOut'),
      pressure: document.getElementById('pressure'),
      pressureOut: document.getElementById('pressureOut'),
      pressureNum: document.getElementById('pressureNum'),
      gap: document.getElementById('gap'),
      gapOut: document.getElementById('gapOut'),
      gapNum: document.getElementById('gapNum'),
      ballast: document.getElementById('ballast'),
      ballastOut: document.getElementById('ballastOut'),
      ballastNum: document.getElementById('ballastNum'),
      electrode: document.getElementById('electrode'),
      electrodeOut: document.getElementById('electrodeOut'),
      electrodeNum: document.getElementById('electrodeNum'),
      voltageNum: document.getElementById('voltageNum'),
      toggle: document.getElementById('toggle'),
      reset: document.getElementById('reset'),
      vb: document.getElementById('vb'),
      mode: document.getElementById('mode'),
      i: document.getElementById('i'),
      ep: document.getElementById('ep'),
      lensLbl: document.getElementById('lensLbl'),
      mA: document.getElementById('mA'),
      mB: document.getElementById('mB'),
      mgamma: document.getElementById('mgamma'),
      mp_mbar: document.getElementById('mp_mbar'),
      mp_torr: document.getElementById('mp_torr'),
      md_cm: document.getElementById('md_cm'),
      md_m: document.getElementById('md_m'),
      mpd: document.getElementById('mpd'),
      mApd: document.getElementById('mApd'),
      mlnApd: document.getElementById('mlnApd'),
      m1g: document.getElementById('m1g'),
      mlnln: document.getElementById('mlnln'),
      mden: document.getElementById('mden'),
      mVb: document.getElementById('mVb'),
      mVb_kv: document.getElementById('mVb_kv'),
      mV: document.getElementById('mV'),
      md2: document.getElementById('md2'),
      mE: document.getElementById('mE'),
      mp2: document.getElementById('mp2'),
      mEp: document.getElementById('mEp'),
      mR: document.getElementById('mR'),
      mVp: document.getElementById('mVp'),
      mI: document.getElementById('mI'),
      mBright: document.getElementById('mBright'),
      boom: document.getElementById('boom'),
      boomText: document.getElementById('boomText'),
      boomReset: document.getElementById('boomReset')
    };

    const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
    const lerp = (a,b,t) => a + (b-a)*t;

    // Fast smoothstep-ish sigmoid
    const sCurve = (x) => 1 / (1 + Math.exp(-x));

    function resize(){
      const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
      const r = (canvasWrap || canvas).getBoundingClientRect();
      canvas.width = Math.max(2, Math.floor(r.width * dpr));
      canvas.height = Math.max(2, Math.floor(r.height * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0);
      state.w = r.width;
      state.h = r.height;
      state.dpr = dpr;
    }

    // Gas parameters (approx, for plausible behavior).
    // A and B in Paschen law (Townsend form). In the UI we present SI units (p in Pa, d in m).
    // Vb = (B p d) / ( ln(A p d) - ln( ln(1 + 1/gamma) ) )
    // References vary widely; these are tuned for a nice interactive prototype.
    const gases = {
      neon: {
        label: 'Ne',
        A: 15.0,
        B: 365.0,
        gamma: 0.02,
        // Color palette
        rgb: [255, 70, 35],
        rgb2: [255, 160, 90],
        lineHueJitter: 0.04,
        glowK: 1.15,
        flicker: 0.08
      },
      argon: {
        label: 'Ar',
        A: 12.0,
        B: 180.0,
        gamma: 0.02,
        rgb: [125, 170, 255],
        rgb2: [210, 235, 255],
        lineHueJitter: 0.06,
        glowK: 1.0,
        flicker: 0.10
      },
      helium: {
        label: 'He',
        A: 2.7,
        B: 27.0,
        gamma: 0.01,
        rgb: [255, 210, 140],
        rgb2: [255, 240, 210],
        lineHueJitter: 0.03,
        glowK: 0.85,
        flicker: 0.06
      },
      nitrogen: {
        label: 'N₂',
        A: 12.0,
        B: 365.0,
        gamma: 0.015,
        rgb: [120, 80, 255],
        rgb2: [180, 155, 255],
        lineHueJitter: 0.08,
        glowK: 1.05,
        flicker: 0.12
      },
      mercury: {
        label: 'Hg+Ar',
        // treat as argon-start + mercury lines: green/blue
        A: 12.0,
        B: 180.0,
        gamma: 0.02,
        rgb: [80, 255, 210],
        rgb2: [95, 160, 255],
        lineHueJitter: 0.10,
        glowK: 1.1,
        flicker: 0.10
      }
    };

    function toPaFromMbar(mbar){
      // 1 mbar = 100 Pa
      return mbar * 100;
    }

    function toMFromCm(cm){
      return cm / 100;
    }

    function paschenAB_SI({A,B}){
      // Conversion from (Torr, cm) to (Pa, m).
      // 1 Torr * 1 cm = 133.322 Pa * 0.01 m = 1.33322 Pa·m
      const k = 133.322 * 0.01;
      return { A_SI: A / k, B_SI: B / k };
    }

    function paschenBreakdownV({A,B,gamma}, pPa, dM){
      // Guard against invalid ranges. If term becomes <= 0, return Infinity.
      const {A_SI, B_SI} = paschenAB_SI({A,B});
      const pd = Math.max(1e-12, pPa * dM);
      const lnApd = Math.log(A_SI * pd);
      const lnln = Math.log(Math.log(1 + 1/Math.max(1e-9, gamma)));
      const denom = lnApd - lnln;
      if (!isFinite(denom) || denom <= 0.02) return Infinity;
      const vb = (B_SI * pd) / denom;
      return vb;
    }

    function updateMath(params, derived){
      const { g, v, pMbar, pPa, dCm, dM, RkOhm, vb } = params;
      const {
        pd,
        Apd,
        lnApd,
        onePlusInvGamma,
        lnln,
        denom,
        E,
        EoverP,
        vPlasmaApprox,
        iApproxA,
        brightnessEst
      } = derived;

      const abSI = paschenAB_SI(g);
      if (el.mA) el.mA.textContent = fmt(abSI.A_SI, 3);
      if (el.mB) el.mB.textContent = fmt(abSI.B_SI, 2);
      if (el.mgamma) el.mgamma.textContent = fmt(g.gamma, 4);
      if (el.mp_mbar) el.mp_mbar.textContent = fmt(pMbar, 2);
      if (el.mp_torr) el.mp_torr.textContent = fmt(pPa, 0);
      if (el.md_cm) el.md_cm.textContent = fmt(dCm, 2);
      if (el.md_m) el.md_m.textContent = fmt(dM, 3);
      if (el.mpd) el.mpd.textContent = fmt(pd, 3);

      if (el.mApd) el.mApd.textContent = fmt(Apd, 3);
      if (el.mlnApd) el.mlnApd.textContent = fmt(lnApd, 4);
      if (el.m1g) el.m1g.textContent = fmt(onePlusInvGamma, 3);
      if (el.mlnln) el.mlnln.textContent = fmt(lnln, 4);
      if (el.mden) el.mden.textContent = fmt(denom, 4);

      if (el.mVb) el.mVb.textContent = isFinite(vb) ? fmt(vb, 2) : '∞';
      if (el.mVb_kv) el.mVb_kv.textContent = isFinite(vb) ? fmt(vb/1000, 3) : '∞';

      if (el.mV) el.mV.textContent = fmt(v, 0);
      if (el.md2) el.md2.textContent = fmt(dM, 3);
      if (el.mE) el.mE.textContent = isFinite(E) ? fmt(E, 2) : '—';
      if (el.mp2) el.mp2.textContent = fmt(pPa, 0);
      if (el.mEp) el.mEp.textContent = isFinite(EoverP) ? fmt(EoverP, 2) : '—';

      if (el.mR) el.mR.textContent = fmt(Math.max(1, RkOhm)*1000, 0);
      if (el.mVp) el.mVp.textContent = fmt(vPlasmaApprox, 1);
      if (el.mI) el.mI.textContent = fmt(iApproxA*1000, 2);

      if (el.mBright) el.mBright.textContent = fmt(brightnessEst, 3);
    }

    function fmt(n, digits=2){
      if (!isFinite(n)) return '∞';
      return n.toFixed(digits);
    }

    const state = {
      w: 800, h: 600, dpr: 1,
      power: false,
      t: 0,
      // dynamic discharge state
      conducting: false,
      // a slow "memory" for transition
      ionization: 0,
      // flash around breakdown
      breakdownFlash: 0,
      // smoothed current
      iA: 0,
      // smoothed voltage across plasma (for glow)
      vPlasma: 0,
      overloadT: 0,
      exploded: false,
      boomT: 0,
      boomP: [],
      boomShown: false,
      micro: {
        electrons: [],
        atoms: [],
        sparks: [],
        seed: 1,
        collisionRate: 0
      }
    };

    function rand01(){
      state.micro.seed = (1664525 * state.micro.seed + 1013904223) >>> 0;
      return (state.micro.seed >>> 0) / 4294967296;
    }

    function initMicro(){
      const m = state.micro;
      m.electrons.length = 0;
      m.atoms.length = 0;
      m.sparks.length = 0;
      for (let i=0;i<26;i++){
        m.atoms.push({
          x: rand01(),
          y: rand01(),
          ex: 0
        });
      }
      for (let i=0;i<38;i++){
        m.electrons.push({
          x: rand01(),
          y: rand01(),
          vx: 0.25 + rand01()*0.35,
          vy: (rand01()-0.5)*0.25
        });
      }
    }

    function microStep(dt, intensity, color){
      const m = state.micro;
      const rate = clamp(intensity, 0, 1);
      m.collisionRate = lerp(m.collisionRate, rate, 1 - Math.exp(-4*dt));

      for (const a of m.atoms){
        a.ex = Math.max(0, a.ex - dt*1.8);
      }
      for (let i=m.sparks.length-1; i>=0; i--){
        const s = m.sparks[i];
        s.t -= dt;
        if (s.t <= 0) m.sparks.splice(i,1);
      }
      for (const e of m.electrons){
        const speed = lerp(0.35, 1.25, m.collisionRate);
        e.x += e.vx * speed * dt;
        e.y += e.vy * speed * dt;
        e.y += (rand01()-0.5) * 0.12 * dt * (0.5 + m.collisionRate);
        if (e.x > 1.05){
          e.x = -0.05;
          e.y = rand01();
          e.vx = 0.25 + rand01()*0.55;
          e.vy = (rand01()-0.5)*0.35;
        }
        if (e.y < -0.05) e.y = 1.05;
        if (e.y > 1.05) e.y = -0.05;
        const pColl = dt * (0.6 + 7.0*m.collisionRate);
        if (rand01() < pColl){
          const idx = Math.floor(rand01() * m.atoms.length);
          const a = m.atoms[idx];
          if (a){
            a.ex = clamp(a.ex + 0.65 + 0.6*m.collisionRate, 0, 1.6);
            m.sparks.push({x: a.x, y: a.y, t: 0.18, c: color});
          }
        }
      }
    }

    function drawMicroLens(params, lensX, lensY, lensR, dt){
      const g = params.g;
      const base = g.rgb;
      const sec = g.rgb2;
      const mix = clamp(0.35 + 0.50*state.micro.collisionRate, 0, 1);
      const col = [
        lerp(base[0], sec[0], mix),
        lerp(base[1], sec[1], mix),
        lerp(base[2], sec[2], mix)
      ];
      const color = `rgba(${Math.round(col[0])},${Math.round(col[1])},${Math.round(col[2])},`;

      const intensity = clamp((params.powerOn ? 1 : 0) * (params.glowProxy || 0), 0, 1);
      microStep(dt, intensity, [col[0], col[1], col[2]]);

      ctx.save();
      ctx.beginPath();
      ctx.arc(lensX, lensY, lensR, 0, Math.PI*2);
      ctx.clip();

      ctx.fillStyle = 'rgba(0,0,0,0.58)';
      ctx.fillRect(lensX-lensR, lensY-lensR, lensR*2, lensR*2);

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      const bg = ctx.createRadialGradient(lensX, lensY, 10, lensX, lensY, lensR);
      bg.addColorStop(0, `${color}${0.14 + 0.24*state.micro.collisionRate})`);
      bg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = bg;
      ctx.fillRect(lensX-lensR, lensY-lensR, lensR*2, lensR*2);

      for (const a of state.micro.atoms){
        const x = lensX + (a.x-0.5) * lensR*1.55;
        const y = lensY + (a.y-0.5) * lensR*1.55;
        const r = 2.2;
        const ex = clamp(a.ex, 0, 1.2);
        if (ex > 0){
          const gg = ctx.createRadialGradient(x,y,0.5, x,y, 16);
          gg.addColorStop(0, `${color}${0.12*ex})`);
          gg.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gg;
          ctx.beginPath();
          ctx.arc(x,y, 16, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.fillStyle = `rgba(255,255,255,${0.14 + 0.10*ex})`;
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
      }

      for (const e of state.micro.electrons){
        const x = lensX + (e.x-0.5) * lensR*1.55;
        const y = lensY + (e.y-0.5) * lensR*1.55;
        ctx.strokeStyle = `rgba(255,255,255,${0.15 + 0.25*state.micro.collisionRate})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x-4, y);
        ctx.lineTo(x+4, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y-4);
        ctx.lineTo(x, y+4);
        ctx.stroke();
      }

      for (const s of state.micro.sparks){
        const x = lensX + (s.x-0.5) * lensR*1.55;
        const y = lensY + (s.y-0.5) * lensR*1.55;
        const a = clamp(s.t / 0.18, 0, 1);
        const gg = ctx.createRadialGradient(x,y,1, x,y, 22);
        gg.addColorStop(0, `rgba(${Math.round(s.c[0])},${Math.round(s.c[1])},${Math.round(s.c[2])},${0.22*a})`);
        gg.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gg;
        ctx.beginPath();
        ctx.arc(x,y, 22, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();

      ctx.restore();

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(lensX, lensY, lensR-1, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    function syncUI(){
      const g = gases[el.gas.value];
      el.gasOut.textContent = g ? g.label : String(el.gas.value);

      const isFocused = (node) => node && document.activeElement === node;

      const v = Number(el.voltage.value);
      el.voltageOut.textContent = `${fmt(v/1000, 2)} кВ`;
      if (el.voltageNum && !isFocused(el.voltageNum)) el.voltageNum.value = fmt(v/1000, 2);

      const p = Number(el.pressure.value);
      el.pressureOut.textContent = `${fmt(p, 1)} мбар`;
      if (el.pressureNum && !isFocused(el.pressureNum)) el.pressureNum.value = fmt(p, 1);

      const d = Number(el.gap.value);
      el.gapOut.textContent = `${fmt(d, 1)} см`;
      if (el.gapNum && !isFocused(el.gapNum)) el.gapNum.value = fmt(d, 1);

      const r = Number(el.ballast.value);
      el.ballastOut.textContent = `${fmt(r, 1)} кОм`;
      if (el.ballastNum && !isFocused(el.ballastNum)) el.ballastNum.value = fmt(r, 0);

      const e = Number(el.electrode.value);
      el.electrodeOut.textContent = fmt(e, 2);
      if (el.electrodeNum && !isFocused(el.electrodeNum)) el.electrodeNum.value = fmt(e, 2);

      const a = 0.15;

      // Compute breakdown threshold
      const pPa = toPaFromMbar(p);
      const dM = toMFromCm(d);
      const vb = paschenBreakdownV(g, pPa, dM);
      el.vb.textContent = isFinite(vb) ? `${fmt(vb/1000, 2)} кВ` : '∞';

      // Derived values for the formulas panel (static-ish, for educational display)
      const abSI = paschenAB_SI(g);
      const pd = Math.max(1e-12, pPa * dM);
      const Apd = abSI.A_SI * pd;
      const lnApd = Math.log(Apd);
      const onePlusInvGamma = 1 + 1/Math.max(1e-9, g.gamma);
      const lnln = Math.log(Math.log(onePlusInvGamma));
      const denom = lnApd - lnln;

      const E = dM > 0 ? v / dM : Infinity; // V/m
      const EoverP = pPa > 0 ? (E / pPa) : Infinity; // V/(m·Pa)

      const Vglow0 = 180 + (g.label === 'He' ? 120 : 0) + (g.label === 'N₂' ? 80 : 0);
      const vPlasmaApprox = clamp(Vglow0, 70, 450);
      const R = Math.max(1, r) * 1000;
      const canConduct = state.power && isFinite(vb) && (state.conducting || v >= vb);
      const iApproxA = canConduct ? Math.max(0, v - vPlasmaApprox) / R : 0;

      const epThresh = 10.5;
      const epGain = sCurve((EoverP - epThresh) / 2.2);
      const i_mA = iApproxA * 1000;
      const iGain = Math.sqrt(clamp(i_mA / 6.0, 0, 1));
      const brightnessEst = clamp(g.glowK * epGain * iGain, 0, 2);

      if (el.lensLbl){
        const coll = clamp(brightnessEst, 0, 1) * (state.power ? 1 : 0);
        el.lensLbl.textContent = `столкновения: ${fmt(coll, 2)}`;
      }

      updateMath(
        { g, v, pMbar: p, pPa, dCm: d, dM, RkOhm: r, electrodeHeat: e, ambient: a, vb },
        { pd, Apd, lnApd, onePlusInvGamma, lnln, denom, E, EoverP, vPlasmaApprox, iApproxA, brightnessEst }
      );

      return { g, v, pMbar: p, pPa, dCm: d, dM, RkOhm: r, electrodeHeat: e, ambient: a, vb };
    }

    function reset(){
      state.conducting = false;
      state.ionization = 0;
      state.breakdownFlash = 0;
      state.iA = 0;
      state.vPlasma = 0;
      state.overloadT = 0;
      state.exploded = false;
      state.boomT = 0;
      state.boomP = [];
      state.boomShown = false;
      state.micro.collisionRate = 0;
      if (el.boom) el.boom.classList.remove('show');
      initMicro();
    }

    function triggerExplosion(){
      if (state.exploded) return;
      state.exploded = true;
      state.boomT = 0;
      state.boomP = [];
      state.boomShown = false;
      if (el.boom){
        el.boom.classList.remove('show');
      }
      for (let i=0;i<46;i++){
        const a = rand01() * Math.PI * 2;
        const s = 80 + rand01()*240;
        state.boomP.push({
          x: 0.5,
          y: 0.52,
          vx: Math.cos(a) * s,
          vy: Math.sin(a) * s - 120,
          r: 1.5 + rand01()*3.5,
          t: 0.6 + rand01()*0.6
        });
      }
      state.power = false;
      el.toggle.textContent = 'Включить';
      state.conducting = false;
      state.ionization = 0;
      state.breakdownFlash = 0;
      state.iA = 0;
      state.vPlasma = 0;
    }

    function srgb(r,g,b,a=1){
      return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},${a})`;
    }

    function drawTube(params, dt){
      const {g, v, pMbar, dCm, dM, vb, electrodeHeat} = params;
      const ambient = 0.15;

      const w = state.w;
      const h = state.h;

      const cx = w*0.5;
      const cy = h*0.52;

      const dN = clamp((dCm - 2) / (60 - 2), 0, 1);
      const tubeLen = clamp(lerp(w*0.52, w*0.88, dN), 320, 860);
      const tubeR = Math.max(18, Math.min(34, h*0.05));

      const x0 = cx - tubeLen*0.5;
      const x1 = cx + tubeLen*0.5;

      // Background
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = `rgba(0,0,0,${0.28 + ambient*0.55})`;
      ctx.fillRect(0,0,w,h);

      // Subtle vignette
      const vign = ctx.createRadialGradient(cx, cy, 20, cx, cy, Math.max(w,h)*0.65);
      vign.addColorStop(0, 'rgba(0,0,0,0)');
      vign.addColorStop(1, `rgba(0,0,0,${0.55 + ambient*0.2})`);
      ctx.fillStyle = vign;
      ctx.fillRect(0,0,w,h);

      // Calculate reduced field E/p for tooltip and glow behavior.
      // In SI: E ~ V / d (V/m), p in Pa.
      const E = dM > 0 ? v / dM : 0;
      const pPa = toPaFromMbar(pMbar);
      const EoverP = pPa > 0 ? (E / pPa) : 0;
      el.ep.textContent = isFinite(EoverP) ? `${fmt(EoverP, 2)} В/(м·Па)` : '—';

      // Discharge model
      // 1) Ionization tends to rise if powered and near/above breakdown (hysteresis)
      // 2) If conducting, we assume plasma drop + ballast defines current.
      const over = (vb === Infinity) ? -1 : (v / Math.max(1e-6, vb));

      // Soft start: electrodes help start emission at lower v (very simplified)
      const assist = lerp(0.88, 1.03, clamp(electrodeHeat, 0, 1));
      const breakdownCondition = state.power && (over * assist) > 1.0;

      // After breakdown, maintain conduction if ionization still present and voltage not too low
      const sustainK = 0.63; // simplified sustaining ratio
      const sustainCondition = state.power && (over * assist) > sustainK;

      // Ionization dynamics
      const targetIon = breakdownCondition ? 1.0 : (sustainCondition ? 0.55 : 0.0);
      const rise = breakdownCondition ? 3.8 : 1.8;
      const fall = 2.4;
      const tau = (targetIon > state.ionization) ? rise : fall;
      state.ionization = lerp(state.ionization, targetIon, 1 - Math.exp(-tau*dt));

      const becameConducting = (!state.conducting) && (state.ionization > 0.72);
      if (becameConducting){
        state.conducting = true;
        state.breakdownFlash = 1.0;
      }
      if (state.conducting && state.ionization < 0.15) state.conducting = false;

      // Plasma voltage drop model (very simplified): depends on gas and current.
      // Typical glow discharge has ~100-300V drop. We'll use 180V baseline + current-dependent.
      const Vglow0 = 180 + (g.label === 'He' ? 120 : 0) + (g.label === 'N₂' ? 80 : 0);
      const Vmin = 70;
      const Vmax = 450;

      // Compute current through ballast if conducting.
      const R = Math.max(1, params.RkOhm) * 1000;
      let iTarget = 0;
      let vPlasmaTarget = 0;
      if (state.power && state.conducting){
        // as ionization rises, plasma drop tends to settle
        vPlasmaTarget = clamp(lerp(Vmax, Vglow0, clamp(state.ionization, 0, 1)) + 60*Math.sqrt(Math.max(0, state.iA*1000)), Vmin, Vmax);
        const vAcrossR = Math.max(0, v - vPlasmaTarget);
        iTarget = vAcrossR / R;
      }

      // Smooth current and plasma voltage
      state.iA = lerp(state.iA, iTarget, 1 - Math.exp(-10*dt));
      state.vPlasma = lerp(state.vPlasma, vPlasmaTarget, 1 - Math.exp(-7*dt));

      const isOver = state.power && state.conducting && (Math.abs(state.iA) > 0.03);
      state.overloadT = isOver ? (state.overloadT + dt) : Math.max(0, state.overloadT - dt*2.2);
      if (!state.exploded && state.overloadT > 0.35){
        triggerExplosion();
      }

      // Brightness model: depends on current and E/p beyond some threshold
      const epThresh = 10.5; // V/(м·Па) - tuned
      const epGain = sCurve((EoverP - epThresh) / 2.2);
      const i_mA = state.iA * 1000;
      const iGain = Math.sqrt(clamp(i_mA / 6.0, 0, 1));
      let glow = g.glowK * epGain * iGain;
      glow *= lerp(0.25, 1.0, clamp(state.ionization, 0, 1));

      // Breakdown flash decays
      state.breakdownFlash = Math.max(0, state.breakdownFlash - dt * 2.2);

      // Flicker (very light, pleasant)
      const flicker = (Math.sin(state.t*13.0) * 0.5 + Math.sin(state.t*23.0) * 0.3 + Math.sin(state.t*41.0) * 0.2);
      const flickerK = 1 + flicker * g.flicker * clamp(glow, 0, 1);
      glow *= flickerK;
      glow = clamp(glow, 0, 1.6);

      const lensR = 90;
      const lensX = w - 6 - lensR;
      const lensY = 18 + lensR;
      drawMicroLens({g, powerOn: state.power, glowProxy: clamp(glow/1.2, 0, 1)}, lensX, lensY, lensR, dt);

      // Update HUD
      el.mode.textContent = state.exploded ? 'авария' : (state.power ? (state.conducting ? 'разряд' : 'зажигание') : 'выкл');
      el.i.textContent = `${fmt(i_mA, 2)} мА`;

      // Tube glass
      const glassGrad = ctx.createLinearGradient(x0, cy-tubeR, x1, cy+tubeR);
      glassGrad.addColorStop(0, 'rgba(255,255,255,0.06)');
      glassGrad.addColorStop(0.5, 'rgba(255,255,255,0.02)');
      glassGrad.addColorStop(1, 'rgba(255,255,255,0.07)');

      // Outer soft glow (ambient)
      const amb = clamp(0.08 + ambient*0.45, 0, 0.6);
      const outer = ctx.createRadialGradient(cx, cy, tubeR, cx, cy, tubeLen*0.62);
      outer.addColorStop(0, `rgba(255,255,255,${amb*0.10})`);
      outer.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = outer;
      ctx.fillRect(0,0,w,h);

      // Draw electrodes
      const elecW = 20;
      const elecH = tubeR*1.45;
      const elecR = 6;

      function roundRect(x,y,ww,hh,r){
        ctx.beginPath();
        const rr = Math.min(r, ww*0.5, hh*0.5);
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+ww, y, x+ww, y+hh, rr);
        ctx.arcTo(x+ww, y+hh, x, y+hh, rr);
        ctx.arcTo(x, y+hh, x, y, rr);
        ctx.arcTo(x, y, x+ww, y, rr);
        ctx.closePath();
      }

      // Plasma glow inside
      const insideX0 = x0 + elecW + 10;
      const insideX1 = x1 - elecW - 10;

      // Glow color mixing
      const base = g.rgb;
      const sec = g.rgb2;
      const mix = clamp(0.35 + 0.45*epGain + 0.25*(state.breakdownFlash), 0, 1);
      const col = [
        lerp(base[0], sec[0], mix),
        lerp(base[1], sec[1], mix),
        lerp(base[2], sec[2], mix)
      ];

      // Additive glow layers
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      // Main tube glow (soft)
      const g1 = ctx.createRadialGradient(cx, cy, tubeR*0.15, cx, cy, tubeLen*0.56);
      const g1a = clamp(0.06 + glow*0.22, 0, 0.35);
      g1.addColorStop(0, srgb(col[0], col[1], col[2], g1a));
      g1.addColorStop(0.6, srgb(col[0], col[1], col[2], g1a*0.35));
      g1.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g1;
      ctx.fillRect(0,0,w,h);

      // Inside column glow (more concentrated)
      const a2 = clamp(0.10 + glow*0.45, 0, 0.75);
      const g2 = ctx.createLinearGradient(insideX0, cy, insideX1, cy);
      g2.addColorStop(0, srgb(col[0], col[1], col[2], a2*0.55));
      g2.addColorStop(0.25, srgb(col[0], col[1], col[2], a2));
      g2.addColorStop(0.75, srgb(col[0], col[1], col[2], a2));
      g2.addColorStop(1, srgb(col[0], col[1], col[2], a2*0.55));

      // "Striation" lines for visual richness (not physically exact)
      const lines = Math.floor(10 + glow*22);
      for (let k=0;k<lines;k++){
        const t = (k + 0.5)/lines;
        const x = lerp(insideX0, insideX1, t);
        const wave = Math.sin(state.t*2.8 + t*12.0) * 0.5 + Math.sin(state.t*5.2 + t*7.0)*0.5;
        const amp = (0.6 + 0.4*Math.sin(t*3.1415)) * (0.3 + glow);
        const aLine = clamp((0.003 + glow*0.020) * (0.55 + 0.45*Math.sin(t*12.0 + state.t*7.0)), 0, 0.055);
        const r = col[0] * (0.92 + 0.08*Math.sin(t*20.0));
        const gg = col[1] * (0.92 + 0.08*Math.sin(t*14.0 + 1));
        const b = col[2] * (0.92 + 0.08*Math.sin(t*16.0 + 2));
        ctx.strokeStyle = srgb(r, gg, b, aLine);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, cy - tubeR*0.55 - wave*amp*6);
        ctx.lineTo(x, cy + tubeR*0.55 + wave*amp*6);
        ctx.stroke();
      }

      // Glow column fill (rounded)
      ctx.fillStyle = g2;
      roundRect(insideX0, cy - tubeR*0.62, insideX1 - insideX0, tubeR*1.24, tubeR*0.62);
      ctx.fill();

      // Breakdown flash (short and bright)
      if (state.breakdownFlash > 0){
        const bf = state.breakdownFlash;
        const aF = clamp(0.08 + bf*0.35, 0, 0.55);
        const flash = ctx.createRadialGradient(cx, cy, tubeR*0.5, cx, cy, tubeLen*0.62);
        flash.addColorStop(0, srgb(255, 255, 255, aF));
        flash.addColorStop(0.7, srgb(col[0], col[1], col[2], aF*0.15));
        flash.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = flash;
        ctx.fillRect(0,0,w,h);
      }

      ctx.restore();

      // Tube body
      ctx.save();
      // glass outline
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.lineWidth = 2;
      roundRect(x0, cy - tubeR, tubeLen, tubeR*2, tubeR);
      ctx.stroke();

      // glass fill
      ctx.fillStyle = glassGrad;
      roundRect(x0, cy - tubeR, tubeLen, tubeR*2, tubeR);
      ctx.fill();

      // Specular highlight
      const spec = ctx.createLinearGradient(x0, cy - tubeR, x1, cy - tubeR);
      spec.addColorStop(0, 'rgba(255,255,255,0.05)');
      spec.addColorStop(0.3, 'rgba(255,255,255,0.12)');
      spec.addColorStop(0.6, 'rgba(255,255,255,0.06)');
      spec.addColorStop(1, 'rgba(255,255,255,0.03)');
      ctx.fillStyle = spec;
      roundRect(x0+6, cy - tubeR + 6, tubeLen-12, tubeR*0.65, tubeR*0.4);
      ctx.fill();
      ctx.restore();

      // Electrodes glow / cathode fall hint
      const endGlow = clamp(glow, 0, 1) * 0.45;
      if (endGlow > 0){
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const leftG = ctx.createRadialGradient(insideX0, cy, 6, insideX0, cy, tubeR*1.3);
        leftG.addColorStop(0, srgb(col[0], col[1], col[2], 0.20*endGlow));
        leftG.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = leftG; ctx.fillRect(0,0,w,h);

        const rightG = ctx.createRadialGradient(insideX1, cy, 6, insideX1, cy, tubeR*1.3);
        rightG.addColorStop(0, srgb(col[0], col[1], col[2], 0.14*endGlow));
        rightG.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = rightG; ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      // Electrode metal
      const heat = clamp(electrodeHeat, 0, 1);
      const hot = clamp(heat * (state.power ? 1 : 0.6), 0, 1);
      const er = lerp(240, 255, hot);
      const eg = lerp(240, 95, hot);
      const eb = lerp(255, 70, hot);
      const ea = lerp(0.14, 0.26, hot);
      ctx.fillStyle = `rgba(${Math.round(er)},${Math.round(eg)},${Math.round(eb)},${ea})`;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1;
      roundRect(x0+8, cy - elecH*0.5, elecW, elecH, elecR);
      ctx.fill();
      ctx.stroke();
      roundRect(x1-elecW-8, cy - elecH*0.5, elecW, elecH, elecR);
      ctx.fill();
      ctx.stroke();

      // Integrated circuit: DC source + ballast resistor connected to the lamp.
      // Place the source and resistor directly under the tube.
      {
        const iOn = state.power && (Math.abs(state.iA) > 0.0002);
        const overload = iOn && (Math.abs(state.iA) > 0.03);
        const wire = 'rgba(255,255,255,0.24)';
        const wireOn = overload ? 'rgba(255,90,90,0.75)' : 'rgba(120,255,205,0.65)';
        const xL = x0 + 8; // left electrode outer edge
        const xR = x1 - 8; // right electrode outer edge
        const yC = cy;
        const yBus = Math.min(h - 44, cy + tubeR + 78);

        // Component layout under the tube
        const battW = 36;
        const battGap = 12;
        const resW = 92;

        const mid = cx;
        const battX = clamp(mid - (resW*0.5 + 26 + battW), xL + 10, xR - (resW + battW + 60));
        const resX0 = clamp(mid + 20, xL + battW + 40, xR - (resW + 10));
        const yComp = yBus;

        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = wire;

        // Down wires from electrodes
        ctx.beginPath();
        ctx.moveTo(xL, yC);
        ctx.lineTo(xL, yBus);
        ctx.moveTo(xR, yC);
        ctx.lineTo(xR, yBus);
        ctx.stroke();

        // Bottom wire (series path): left node -> switch -> battery -> resistor -> right node
        const swX0 = xL + 24;
        const swX1 = swX0 + 16;
        const swY = yBus;
        ctx.beginPath();
        ctx.moveTo(xL, yBus);
        ctx.lineTo(swX0, yBus);
        ctx.stroke();

        // Switch symbol
        ctx.beginPath();
        ctx.moveTo(swX0, swY);
        ctx.lineTo(swX0, swY);
        ctx.moveTo(swX1, swY);
        ctx.lineTo(swX1, swY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(swX0, swY);
        if (state.power){
          ctx.lineTo(swX1, swY);
        } else {
          ctx.lineTo(swX0 + 10, swY - 10);
        }
        ctx.stroke();

        // Wire after the switch
        ctx.beginPath();
        ctx.moveTo(swX1, yBus);
        ctx.lineTo(battX, yBus);
        ctx.stroke();

        // Battery symbol inline
        const b1 = battX + 10;
        const b2 = battX + 10 + battGap;
        ctx.beginPath();
        ctx.moveTo(b1, yComp - 14);
        ctx.lineTo(b1, yComp + 14);
        ctx.moveTo(b2, yComp - 9);
        ctx.lineTo(b2, yComp + 9);
        ctx.stroke();

        // Wire battery -> resistor
        ctx.beginPath();
        ctx.moveTo(b2, yBus);
        ctx.lineTo(resX0, yBus);
        ctx.stroke();

        // Resistor zigzag inline
        const rz = yComp;
        ctx.beginPath();
        ctx.moveTo(resX0, rz);
        ctx.lineTo(resX0 + 10, rz);
        ctx.lineTo(resX0 + 16, rz - 8);
        ctx.lineTo(resX0 + 24, rz + 8);
        ctx.lineTo(resX0 + 32, rz - 8);
        ctx.lineTo(resX0 + 40, rz + 8);
        ctx.lineTo(resX0 + 48, rz - 8);
        ctx.lineTo(resX0 + 56, rz + 8);
        ctx.lineTo(resX0 + 64, rz - 8);
        ctx.lineTo(resX0 + 72, rz + 8);
        ctx.lineTo(resX0 + 80, rz - 8);
        ctx.lineTo(resX0 + 86, rz);
        ctx.stroke();

        // Wire resistor -> right node
        ctx.beginPath();
        ctx.moveTo(resX0 + 86, yBus);
        ctx.lineTo(xR, yBus);
        ctx.stroke();

        // Current indicator: highlight the conduction path
        if (iOn){
          ctx.save();
          ctx.lineWidth = overload ? 4 : 3;
          ctx.strokeStyle = wireOn;
          ctx.globalAlpha = overload ? (0.55 + 0.25*Math.sin(state.t*10)) : 0.55;

          // Down wires from electrodes
          ctx.beginPath();
          ctx.moveTo(xL, yC);
          ctx.lineTo(xL, yBus);
          ctx.moveTo(xR, yC);
          ctx.lineTo(xR, yBus);
          ctx.stroke();

          // Bottom path (including switch)
          ctx.beginPath();
          ctx.moveTo(xL, yBus);
          ctx.lineTo(swX0, yBus);
          if (state.power){
            ctx.lineTo(swX1, yBus);
          }
          ctx.lineTo(battX, yBus);
          ctx.lineTo(resX0, yBus);
          ctx.lineTo(resX0 + 86, yBus);
          ctx.lineTo(xR, yBus);
          ctx.stroke();

          // Resistor emphasis
          ctx.beginPath();
          ctx.moveTo(resX0, rz);
          ctx.lineTo(resX0 + 10, rz);
          ctx.lineTo(resX0 + 16, rz - 8);
          ctx.lineTo(resX0 + 24, rz + 8);
          ctx.lineTo(resX0 + 32, rz - 8);
          ctx.lineTo(resX0 + 40, rz + 8);
          ctx.lineTo(resX0 + 48, rz - 8);
          ctx.lineTo(resX0 + 56, rz + 8);
          ctx.lineTo(resX0 + 64, rz - 8);
          ctx.lineTo(resX0 + 72, rz + 8);
          ctx.lineTo(resX0 + 80, rz - 8);
          ctx.lineTo(resX0 + 86, rz);
          ctx.stroke();

          ctx.restore();
        }

        // Labels
        ctx.fillStyle = 'rgba(255,255,255,0.72)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(state.power ? 'SW: ON' : 'SW: OFF', swX0 + 10, yComp - 20);
        ctx.fillText('DC', battX + 12, yComp - 20);
        ctx.fillText(`R=${fmt(params.RkOhm,1)} кОм`, resX0 + 44, yComp - 20);
        ctx.fillText(`V=${fmt(v/1000,2)} кВ   I=${fmt(state.iA*1000,2)} мА${overload?'  OVER':''}`, cx, yBus + 28);

        // Brightness indicator (0..1)
        const br = clamp(glow / 1.2, 0, 1);
        const barW = 132;
        const barH = 8;
        const barX = cx - barW*0.5;
        const barY = yBus + 40;
        ctx.textAlign = 'left';
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.fillText('Яркость', barX, barY + 18);
        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);
        ctx.fillStyle = srgb(col[0], col[1], col[2], overload ? 0.35 : 0.55);
        ctx.fillRect(barX, barY, Math.max(0, Math.floor(barW * br)), barH);
        ctx.restore();
      }

      // Labels above tube (free space under tube for the circuit)
      const yLbl1 = Math.max(22, cy - tubeR - 30);
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`Gas: ${g.label}   p=${fmt(pMbar,1)} мбар   d=${fmt(dCm,1)} см`, cx, yLbl1);

      if (state.exploded){
        state.boomT += dt;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        const bt = state.boomT;
        const aF = clamp(0.85 - bt*1.4, 0, 0.9);
        if (aF > 0){
          const gx = cx;
          const gy = cy;
          const flash = ctx.createRadialGradient(gx, gy, 6, gx, gy, 220);
          flash.addColorStop(0, srgb(255, 255, 255, aF));
          flash.addColorStop(0.4, srgb(255, 120, 80, aF*0.55));
          flash.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = flash;
          ctx.fillRect(0,0,w,h);
        }

        ctx.globalCompositeOperation = 'source-over';
        for (let i=state.boomP.length-1; i>=0; i--){
          const p = state.boomP[i];
          p.t -= dt;
          if (p.t <= 0){
            state.boomP.splice(i,1);
            continue;
          }
          p.vy += 520*dt;
          p.x += (p.vx*dt) / w;
          p.y += (p.vy*dt) / h;
          const px = p.x * w;
          const py = p.y * h;
          const aa = clamp(p.t, 0, 1);
          ctx.fillStyle = srgb(255, 150, 90, 0.35*aa);
          ctx.beginPath();
          ctx.arc(px, py, p.r*2.2, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = srgb(255, 255, 255, 0.35*aa);
          ctx.beginPath();
          ctx.arc(px, py, p.r, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();

        if (!state.boomShown && state.boomT > 0.75){
          state.boomShown = true;
          if (el.boom){
            el.boom.classList.add('show');
          }
        }
      }

      // If not powered: show very subtle idle noise
      if (!state.power){
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const a = 0.03 + ambient*0.07;
        const idle = ctx.createRadialGradient(cx, cy, tubeR, cx, cy, tubeLen*0.55);
        idle.addColorStop(0, `rgba(80,110,255,${a})`);
        idle.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = idle;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }
    }

    function tick(now){
      const t = now * 0.001;
      const dt = clamp(t - state.t, 0, 0.05);
      state.t = t;

      const params = syncUI();
      drawTube(params, dt);

      requestAnimationFrame(tick);
    }

    function bind(){
      const update = () => syncUI();

      const num = {
        voltageKV: el.voltageNum,
        pressure: el.pressureNum,
        gap: el.gapNum,
        ballast: el.ballastNum,
        electrode: el.electrodeNum
      };

      function clampNum(v, min, max){
        if (!isFinite(v)) return min;
        return Math.max(min, Math.min(max, v));
      }

      function wireNumberToRange(numberEl, rangeEl, mapToRange, mapFromRange){
        if (!numberEl || !rangeEl) return;
        const onNum = () => {
          const v = mapToRange(Number(numberEl.value));
          const min = Number(rangeEl.min);
          const max = Number(rangeEl.max);
          rangeEl.value = String(clampNum(v, min, max));
          syncUI();
        };
        const onRange = () => {
          numberEl.value = String(mapFromRange(Number(rangeEl.value)));
        };
        numberEl.addEventListener('input', onNum);
        numberEl.addEventListener('change', onNum);
        rangeEl.addEventListener('input', onRange);
        rangeEl.addEventListener('change', onRange);
      }

      // Number inputs: keep same units as the visible labels
      // Voltage number input is in kV, range is in V
      wireNumberToRange(num.voltageKV, el.voltage, (kv) => kv*1000, (v) => fmt(v/1000, 2));
      wireNumberToRange(num.pressure, el.pressure, (mbar) => mbar, (mbar) => fmt(mbar, 1));
      wireNumberToRange(num.gap, el.gap, (cm) => cm, (cm) => fmt(cm, 1));
      wireNumberToRange(num.ballast, el.ballast, (kohm) => kohm, (kohm) => fmt(kohm, 0));
      wireNumberToRange(num.electrode, el.electrode, (x) => x, (x) => fmt(x, 2));

      ['input','change'].forEach(evt => {
        el.gas.addEventListener(evt, update);
        el.voltage.addEventListener(evt, update);
        el.pressure.addEventListener(evt, update);
        el.gap.addEventListener(evt, update);
        el.ballast.addEventListener(evt, update);
        el.electrode.addEventListener(evt, update);
      });

      function enableUpDownForRange(rangeEl){
        if (!rangeEl) return;
        rangeEl.addEventListener('keydown', (e) => {
          if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown') return;
          e.preventDefault();
          const step = Number(rangeEl.step) || 1;
          const min = Number(rangeEl.min);
          const max = Number(rangeEl.max);
          const dir = (e.key === 'ArrowUp') ? 1 : -1;
          const next = clamp(Number(rangeEl.value) + dir*step, min, max);
          rangeEl.value = String(next);
          syncUI();
        });
      }

      enableUpDownForRange(el.pressure);
      enableUpDownForRange(el.gap);

      el.toggle.addEventListener('click', () => {
        if (state.exploded) return;
        state.power = !state.power;
        el.toggle.textContent = state.power ? 'Выключить' : 'Включить';
        if (state.power){
          if (!state.micro.atoms.length || !state.micro.electrons.length) initMicro();
        } else {
          reset();
        }
      });

      if (el.boomReset){
        el.boomReset.addEventListener('click', () => {
          reset();
          syncUI();
        });
      }
      el.reset.addEventListener('click', () => {
        el.voltage.value = '2000';
        el.pressure.value = '20';
        el.gap.value = '25';
        el.ballast.value = '50';
        el.electrode.value = '0.35';
        el.gas.value = 'neon';
        reset();
        syncUI();
      });

      window.addEventListener('resize', () => {
        resize();
      }, { passive: true });

      // Keyboard
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space'){
          e.preventDefault();
          el.toggle.click();
        }
        if (e.code === 'KeyR'){
          e.preventDefault();
          el.reset.click();
        }
      });
    }

    // Init
    bind();
    resize();
    initMicro();
    syncUI();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
