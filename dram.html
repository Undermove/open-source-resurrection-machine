<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>DRAM (1T1C) — RAS/CAS/Refresh (учебная симуляция)</title>
  <style>
    :root{
      --bg0:#07070b;
      --bg1:#0d0d16;
      --stroke:rgba(255,255,255,.12);
      --text:#e9e9f3;
      --muted:rgba(233,233,243,.7);
      --accent:#7cd1ff;
      --ok:#7aff8f;
      --warn:#ffcf5b;
      --bad:#ff6b6b;
    }
    html, body{
      margin:0;
      height:100%;
      background: radial-gradient(circle at 50% 20%, var(--bg1) 0%, var(--bg0) 70%);
      color:var(--text);
      font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif;
      overflow:hidden;
    }

    #app{
      position:fixed;
      inset:0;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap: 14px;
      padding: 14px;
      box-sizing: border-box;
      height: 100%;
    }
    @media (max-width: 980px){
      #app{ grid-template-columns: 1fr; grid-template-rows: 1fr auto; }
      #logPanel{ max-height: 36svh; }
      #canvasWrap{ min-height: 52svh; }
    }

    #canvasWrap{
      border: 1px solid var(--stroke);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(0,0,0,.18);
      min-height: 0;
    }
    canvas{ display:block; width:100%; height:100%; }

    #logPanel{
      border: 1px solid var(--stroke);
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 0;
    }

    #logPanelHeader{
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    #logPanelHeader .t{ font-weight: 800; font-size: 13px; letter-spacing: .2px; }
    #logPanelHeader .s{ font-size: 11px; color: var(--muted); line-height: 1.25; }

    #timeline{
      padding: 10px 10px 0;
      overflow:auto;
      flex: 1 1 auto;
      min-height: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre;
    }

    .logline{
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.12);
      margin-bottom: 8px;
      cursor: default;
    }
    .logline:hover{ border-color: rgba(124,209,255,.35); background: rgba(124,209,255,.06); }

    #detail{
      border-top: 1px solid rgba(255,255,255,.08);
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(233,233,243,.90);
      line-height: 1.35;
      min-height: 84px;
      background: rgba(0,0,0,.12);
    }
    #detail .k{ color: var(--muted); font-size: 11px; margin-bottom: 6px; }
  </style>
</head>
<body>
  <div id="app">
    <div id="canvasWrap">
      <canvas id="view"></canvas>
    </div>
    <aside id="logPanel" aria-label="Simulation log">
      <div id="logPanelHeader">
        <div class="t">Timeline</div>
        <div class="s">Наведи на шаг, чтобы увидеть подробное объяснение. Клик по CPU — настройка операции.</div>
      </div>
      <div id="timeline"></div>
      <div id="detail">
        <div class="k">Explanation</div>
        <div id="detailText">—</div>
      </div>
    </aside>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d', { alpha: true });

    const ui = {
      timeline: document.getElementById('timeline'),
      detailText: document.getElementById('detailText'),
    };

    const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
    const lerp = (a,b,t) => a + (b-a)*t;

    const COLORS = {
      stroke: 'rgba(255,255,255,.12)',
      grid: 'rgba(255,255,255,.06)',
      text: 'rgba(233,233,243,.95)',
      muted: 'rgba(233,233,243,.70)',
      panel: 'rgba(0,0,0,.26)',
      panel2: 'rgba(0,0,0,.42)',
      accent: 'rgba(124,209,255,.95)',
      ok: 'rgba(122,255,143,.95)',
      warn: 'rgba(255,207,91,.95)',
      bad: 'rgba(255,107,107,.95)',
      cpu: 'rgba(124,209,255,.85)',
      mc: 'rgba(255,207,91,.85)',
      dram: 'rgba(122,255,143,.80)',
    };

    const CONFIG = {
      memBytes: 32,
      stepMs: 420,
      packetSpeed: 520, // px/s
    };

    const state = {
      w: 0,
      h: 0,
      dpr: 1,
      t: 0,
      pointer: { x: 0, y: 0, down: false },
      scene: {
        ox: 0,
        oy: 0,
        drag: null,
        nodes: null,
        click: { x: 0, y: 0, moved: false },
      },
      mem: new Uint8Array(CONFIG.memBytes),
      cache: {
        lineSize: 8,
        lineCount: 4,
        lines: [],
        last: { lineIndex: null, byteIndex: null, op: null, flashT: 0 },
      },
      ui: {
        menuOpen: false,
        menuFor: 'cpu',
        op: 'load',
        addr: 0,
        value: 170,
      },
      sim: {
        running: false,
        nextStepAt: 0,
        stepId: 0,
        queue: [],
        packets: [],
        logs: { timeline: [], cpu: [], mc: [], dram: [] },
        dramSig: { cmd: 'IDLE', row: null, col: null, flashT: 0 },
        lastAddr: null,
        lastOp: null,
      },
      layout: {
        nodes: {},
        buttons: {},
        menu: null,
        logs: {},
      }
    };

    function toWorld(px, py){
      return { x: px - state.scene.ox, y: py - state.scene.oy };
    }

    function toScreen(px, py){
      return { x: px + state.scene.ox, y: py + state.scene.oy };
    }

    function initCache(){
      state.cache.lines = new Array(state.cache.lineCount).fill(0).map(() => ({
        valid: false,
        tag: 0,
        dirty: false,
        data: new Uint8Array(state.cache.lineSize),
      }));
      state.cache.last = { lineIndex: null, byteIndex: null, op: null, flashT: 0 };
    }

    function roundRect(c, x, y, w, h, r){
      const rr = Math.min(r, w*0.5, h*0.5);
      c.beginPath();
      c.moveTo(x+rr, y);
      c.arcTo(x+w, y, x+w, y+h, rr);
      c.arcTo(x+w, y+h, x, y+h, rr);
      c.arcTo(x, y+h, x, y, rr);
      c.arcTo(x, y, x+w, y, rr);
      c.closePath();
    }

    function hitRect(px, py, r){
      return !!r && px >= r.x && py >= r.y && px <= r.x + r.w && py <= r.y + r.h;
    }

    function explainEvent(kind, device, text){
      const t = String(text);
      if (device === 'CPU' && t.startsWith('LD')){
        return 'CPU выполняет инструкцию чтения (load). Ядро формирует запрос на чтение по адресу и отправляет его в контроллер памяти. В реальности это обычно обслуживается кешем, но здесь мы показываем путь до DRAM.';
      }
      if (device === 'CPU' && t.startsWith('ST')){
        return 'CPU выполняет инструкцию записи (store). Запись обычно попадает в кеш и помечается dirty, а в DRAM уходит позже. Здесь мы упрощаем и показываем запись как последовательность команд в DRAM.';
      }
      if (device === 'MC' && t.includes('decode')){
        return 'Контроллер памяти декодирует адрес и разбивает его на компоненты DRAM (условно: row/col). В реальном DDR адресация сложнее (bank/group/rank, burst), но идея row/col сохраняется.';
      }
      if (device === 'MC' && t.startsWith('ACT')){
        return 'ACTIVATE (ACT): команда активации строки. Это соответствует сигналу RAS: выбирается строка массива, и она подключается к sense amplifiers (row buffer).';
      }
      if (device === 'DRAM' && t.startsWith('ACT')){
        return 'DRAM получила ACT: поднимается wordline для выбранной строки (RAS), ячейки строки подключаются к bitlines, данные усиливаются sense amplifiers. Это делает доступ к колонкам этой строки возможным.';
      }
      if (device === 'DRAM' && t.startsWith('RD')){
        return 'READ (RD): команда чтения по колонке (CAS). DRAM выдаёт данные из активной строки/колонки на шину данных. У настоящей DRAM чтение разрушительное, поэтому далее происходит восстановление заряда.';
      }
      if (device === 'DRAM' && t.startsWith('WR')){
        return 'WRITE (WR): команда записи по колонке (CAS). Контроллер подаёт данные на шину, а DRAM записывает их в выбранную ячейку активной строки.';
      }
      if (t.startsWith('PRE')){
        return 'PRECHARGE (PRE): закрытие строки. Bitlines приводятся к опорному уровню (примерно Vdd/2), чтобы следующая активация строки могла корректно “сдвинуть” bitline и быть усиленной sense amplifier.';
      }
      return 'Шаг симуляции. Этот проект намеренно упрощает реальные протоколы DDR, чтобы визуально показать цепочку CPU → контроллер → DRAM.';
    }

    function renderTimeline(){
      if (!ui.timeline) return;
      ui.timeline.innerHTML = '';
      for (const e of state.sim.logs.timeline){
        const div = document.createElement('div');
        div.className = 'logline';
        div.textContent = e.line;
        div.title = e.explain;
        div.addEventListener('mouseenter', () => {
          if (ui.detailText) ui.detailText.textContent = e.explain;
        });
        ui.timeline.appendChild(div);
      }
    }

    function pushEvent(kind, device, text){
      const id = ++state.sim.stepId;
      const line = `${String(id).padStart(3,'0')}  [${device}] ${text}`;
      const explain = explainEvent(kind, device, text);

      state.sim.logs.timeline.unshift({ line, explain });
      if (state.sim.logs.timeline.length > 24) state.sim.logs.timeline.length = 24;

      if (kind === 'CPU'){
        state.sim.logs.cpu.unshift({ line, explain });
        if (state.sim.logs.cpu.length > 8) state.sim.logs.cpu.length = 8;
      } else if (kind === 'MC'){
        state.sim.logs.mc.unshift({ line, explain });
        if (state.sim.logs.mc.length > 8) state.sim.logs.mc.length = 8;
      } else if (kind === 'DRAM'){
        state.sim.logs.dram.unshift({ line, explain });
        if (state.sim.logs.dram.length > 8) state.sim.logs.dram.length = 8;
      }

      renderTimeline();
    }

    function layout(){
      const w = state.w;
      const h = state.h;

      const cx = w * 0.46;
      const cy = h * 0.40;

      const cpuW = clamp(w * 0.34, 260, 420);
      const cpuH = clamp(h * 0.30, 220, 340);
      const dramW = clamp(w * 0.28, 220, 340);
      const dramH = clamp(h * 0.30, 200, 320);
      const gap = clamp(w * 0.06, 30, 80);

      const cpu = { x: cx - cpuW*0.5, y: cy - cpuH*0.5, w: cpuW, h: cpuH, label: 'CPU', key: 'cpu', type: 'rect' };
      const dram = { x: cpu.x + cpuW + gap, y: cy - dramH*0.5, w: dramW, h: dramH, label: 'DRAM', key: 'dram', type: 'rect' };

      // init persistent nodes once; keep user dragging offsets across resizes
      if (!state.scene.nodes){
        state.scene.nodes = {
          cpu: { x: cpu.x, y: cpu.y },
          dram: { x: dram.x, y: dram.y },
        };
      }
      cpu.x = state.scene.nodes.cpu.x; cpu.y = state.scene.nodes.cpu.y;
      dram.x = state.scene.nodes.dram.x; dram.y = state.scene.nodes.dram.y;

      const bus = {
        y: clamp(Math.max(cpu.y + cpu.h, dram.y + dram.h) + 22, 140, h - 120),
        x0: cpu.x + cpu.w + 10,
        x1: dram.x - 10,
      };

      const btnW = 92;
      const btnH = 60;
      const btnGap = 14;
      const rowW = btnW*3 + btnGap*2;
      const bottom = Math.max(cpu.y + cpu.h, dram.y + dram.h);
      let btnY = bottom + 14;
      const maxY = h - btnH - 16;
      btnY = clamp(btnY, 16, maxY);
      const startX = clamp((cpu.x + cpu.w*0.5) - rowW*0.5, 16, w - rowW - 16);
      const buttons = {
        step: { x: startX, y: btnY, w: btnW, h: btnH, label: 'Step', icon: 'step' },
        play: { x: startX + btnW + btnGap, y: btnY, w: btnW, h: btnH, label: state.sim.running ? 'Pause' : 'Play', icon: state.sim.running ? 'pause' : 'play' },
        reset:{ x: startX + (btnW + btnGap)*2, y: btnY, w: btnW, h: btnH, label: 'Reset', icon: 'reset' },
      };

      const menuW = clamp(w * 0.36, 260, 420);
      const menuH = 240;
      const menu = { x: cpu.x + cpu.w*0.5 - menuW*0.5, y: cpu.y - 18 - menuH, w: menuW, h: menuH };

      state.layout = { nodes: { cpu, dram }, buttons, menu, bus };
    }

    function resize(){
      const r = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
      canvas.width = Math.max(2, Math.floor(r.width * dpr));
      canvas.height = Math.max(2, Math.floor(r.height * dpr));
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      state.w = r.width;
      state.h = r.height;
      state.dpr = dpr;
      layout();
    }

    function getPort(node, side){
      if (side === 'right') return { x: node.x + node.w, y: node.y + node.h*0.5 };
      if (side === 'left') return { x: node.x, y: node.y + node.h*0.5 };
      if (side === 'top') return { x: node.x + node.w*0.5, y: node.y };
      if (side === 'bottom') return { x: node.x + node.w*0.5, y: node.y + node.h };
      return { x: node.x + node.w*0.5, y: node.y + node.h*0.5 };
    }

    function polyLen(pts){
      let L = 0;
      for (let i=1; i<pts.length; i++) L += Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
      return Math.max(1e-3, L);
    }

    function pointOnPoly(pts, t){
      const total = polyLen(pts);
      let d = t * total;
      for (let i=1; i<pts.length; i++){
        const a = pts[i-1];
        const b = pts[i];
        const seg = Math.hypot(b.x-a.x, b.y-a.y);
        if (d <= seg){
          const u = (seg <= 1e-6) ? 0 : d/seg;
          return { x: lerp(a.x,b.x,u), y: lerp(a.y,b.y,u) };
        }
        d -= seg;
      }
      return { x: pts[pts.length-1].x, y: pts[pts.length-1].y };
    }

    function addPacket(fromKey, toKey, label, color){
      const A = state.layout.nodes[fromKey];
      const B = state.layout.nodes[toKey];
      const bus = state.layout.bus;
      if (!A || !B || !bus) return;

      const pA = (fromKey === 'dram') ? getPort(A,'left') : getPort(A,'right');
      const pB = (toKey === 'dram') ? getPort(B,'left') : getPort(B,'right');

      const midY = bus.y;
      const pts = [
        {x:pA.x, y:pA.y},
        {x:pA.x + (fromKey==='dram'?-10:10), y:pA.y},
        {x:pA.x + (fromKey==='dram'?-10:10), y:midY},
        {x:pB.x + (toKey==='dram'?-10:10), y:midY},
        {x:pB.x + (toKey==='dram'?-10:10), y:pB.y},
        {x:pB.x, y:pB.y},
      ];
      state.sim.packets.push({ pts, t: 0, label, color });
    }

    function enqueue(step){
      state.sim.queue.push(step);
    }

    function clearSim(){
      state.sim.queue = [];
      state.sim.packets = [];
      state.sim.running = false;
      state.sim.nextStepAt = 0;
      state.sim.stepId = 0;
      state.sim.logs.timeline = [];
      state.sim.logs.cpu = [];
      state.sim.logs.mc = [];
      state.sim.logs.dram = [];
      state.sim.dramSig = { cmd: 'IDLE', row: null, col: null, flashT: 0 };
      state.sim.lastAddr = null;
      state.sim.lastOp = null;
      initCache();
      pushEvent('CPU', 'CPU', 'ready');
    }

    function addrToRowCol(addr){
      const row = Math.floor(addr / 8);
      const col = addr % 8;
      return { row, col };
    }

    function cacheIndexForLine(lineAddr){
      return lineAddr % state.cache.lineCount;
    }

    function cacheTagForLine(lineAddr){
      return Math.floor(lineAddr / state.cache.lineCount);
    }

    function cacheLookup(addr){
      const lineAddr = Math.floor(addr / state.cache.lineSize);
      const index = cacheIndexForLine(lineAddr);
      const tag = cacheTagForLine(lineAddr);
      const byteIndex = addr % state.cache.lineSize;
      const line = state.cache.lines[index];
      const hit = !!line.valid && line.tag === tag;
      return { hit, index, tag, lineAddr, byteIndex, line };
    }

    function cacheWriteBackIfDirty(index){
      const line = state.cache.lines[index];
      if (!line.valid || !line.dirty) return;
      const baseLineAddr = (line.tag * state.cache.lineCount + index);
      const baseAddr = baseLineAddr * state.cache.lineSize;
      for (let i=0; i<state.cache.lineSize; i++){
        const a = baseAddr + i;
        if (a >= 0 && a < state.mem.length) state.mem[a] = line.data[i];
      }
      line.dirty = false;
      pushEvent('MC', 'IMC', `WB line idx=${index} -> DRAM (write-back dirty line)`);
      addPacket('cpu', 'dram', 'WB', COLORS.warn);
    }

    function cacheFillFromMem(index, tag, baseAddr){
      const line = state.cache.lines[index];
      line.valid = true;
      line.tag = tag;
      line.dirty = false;
      for (let i=0; i<state.cache.lineSize; i++){
        const a = baseAddr + i;
        line.data[i] = (a >= 0 && a < state.mem.length) ? state.mem[a] : 0;
      }
    }

    function setDramSig(cmd, row=null, col=null){
      state.sim.dramSig.cmd = cmd;
      state.sim.dramSig.row = row;
      state.sim.dramSig.col = col;
      state.sim.dramSig.flashT = 0.45;
    }

    function queueCpuScenario(){
      const op = state.ui.op;
      const addr = clamp(Math.floor(state.ui.addr), 0, CONFIG.memBytes - 1);
      const value = clamp(Math.floor(state.ui.value), 0, 255);

      const hexAddr = '0x' + addr.toString(16).toUpperCase().padStart(2,'0');

      if (op === 'load'){
        pushEvent('CPU', 'CPU', `LD r0, [${hexAddr}]`);
      } else {
        pushEvent('CPU', 'CPU', `ST [${hexAddr}], r0   ; r0=${value}`);
      }

      enqueue({
        device: 'CPU',
        text: 'L1 lookup',
        run: () => {
          const q = cacheLookup(addr);
          state.cache.last.lineIndex = q.index;
          state.cache.last.byteIndex = q.byteIndex;
          state.cache.last.op = op;
          state.cache.last.flashT = 0.6;
          pushEvent('CPU', 'CPU', `L1 ${q.hit ? 'HIT' : 'MISS'}  line=${q.index} byte=${q.byteIndex}`);
          return true;
        }
      });

      const q0 = cacheLookup(addr);
      if (q0.hit){
        if (op === 'load'){
          enqueue({
            device: 'CPU',
            text: 'return from L1',
            run: () => {
              const q = cacheLookup(addr);
              const v = q.line.data[q.byteIndex];
              pushEvent('CPU', 'CPU', `LOAD result (L1) = ${v} (0x${v.toString(16).padStart(2,'0')})`);
              return true;
            }
          });
        } else {
          enqueue({
            device: 'CPU',
            text: 'store into L1',
            run: () => {
              const q = cacheLookup(addr);
              q.line.data[q.byteIndex] = value;
              q.line.dirty = true;
              pushEvent('CPU', 'CPU', `STORE -> L1 (dirty)  [${hexAddr}] <= ${value}`);
              return true;
            }
          });
        }
        return;
      }

      // MISS: IMC fetches cache line from DRAM (and may write-back dirty victim)
      const lineAddr = Math.floor(addr / state.cache.lineSize);
      const baseAddr = lineAddr * state.cache.lineSize;
      const index = cacheIndexForLine(lineAddr);
      const tag = cacheTagForLine(lineAddr);
      const { row, col } = addrToRowCol(addr);

      enqueue({
        device: 'MC',
        text: 'IMC schedule miss handling',
        run: () => {
          pushEvent('MC', 'IMC', `MISS -> fetch line base=${'0x'+baseAddr.toString(16).toUpperCase().padStart(2,'0')} into L1 idx=${index}`);
          addPacket('cpu', 'dram', 'REQ', COLORS.warn);
          return true;
        }
      });

      enqueue({
        device: 'MC',
        text: 'write-back if needed',
        run: () => {
          cacheWriteBackIfDirty(index);
          return true;
        }
      });

      enqueue({
        device: 'MC',
        text: `issue ACT row=${row}`,
        run: () => {
          pushEvent('MC', 'IMC', `ACT row=${row} (RAS)`);
          addPacket('cpu', 'dram', `ACT r${row}`, COLORS.warn);
          return true;
        }
      });

      enqueue({
        device: 'DRAM',
        text: `ACT row=${row}`,
        run: () => {
          pushEvent('DRAM', 'DRAM', `ACT row=${row} (RAS)`);
          setDramSig('ACT', row, null);
          return true;
        }
      });

      enqueue({
        device: 'DRAM',
        text: `RD col=${col} (burst line)`,
        run: () => {
          pushEvent('DRAM', 'DRAM', `RD col=${col} (CAS)  burst -> fill L1 line`);
          setDramSig('RD', row, col);
          cacheFillFromMem(index, tag, baseAddr);
          addPacket('dram', 'cpu', 'DATA', COLORS.ok);
          return true;
        }
      });

      enqueue({
        device: 'DRAM',
        text: 'PRE',
        run: () => {
          pushEvent('DRAM', 'DRAM', 'PRE (precharge)');
          setDramSig('PRE', null, null);
          return true;
        }
      });

      if (op === 'load'){
        enqueue({
          device: 'CPU',
          text: 'return after fill',
          run: () => {
            const q = cacheLookup(addr);
            const v = q.line.data[q.byteIndex];
            pushEvent('CPU', 'CPU', `LOAD result (after fill) = ${v} (0x${v.toString(16).padStart(2,'0')})`);
            return true;
          }
        });
      } else {
        enqueue({
          device: 'CPU',
          text: 'store after fill',
          run: () => {
            const q = cacheLookup(addr);
            q.line.data[q.byteIndex] = value;
            q.line.dirty = true;
            pushEvent('CPU', 'CPU', `STORE -> L1 (dirty)  [${hexAddr}] <= ${value}`);
            return true;
          }
        });
      }
    }

    function doStep(){
      if (!state.sim.queue.length) return;
      const cur = state.sim.queue.shift();
      try{
        if (cur && cur.run) cur.run();
      }catch(e){
        pushEvent('CPU', 'SIM', `ERROR: ${e && e.message ? e.message : String(e)}`);
        state.sim.running = false;
      }
    }

    function drawNode(n, accent){
      ctx.save();
      ctx.fillStyle = COLORS.panel;
      ctx.strokeStyle = accent || COLORS.stroke;
      roundRect(ctx, n.x, n.y, n.w, n.h, 16);
      ctx.fill();
      ctx.stroke();

      // header strip
      const headerH = 22;
      const col = (n.key === 'cpu') ? COLORS.cpu : ((n.key === 'mc') ? COLORS.mc : COLORS.dram);
      ctx.fillStyle = col;
      ctx.globalAlpha = 0.18;
      roundRect(ctx, n.x+1, n.y+1, n.w-2, headerH, 14);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = COLORS.text;
      ctx.font = '700 15px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (n.key === 'dram'){
        // Keep DRAM title in the header so the internal grid has space.
        ctx.fillText('DRAM', n.x + n.w*0.5, n.y + 13);
      } else {
        const lines = String(n.label).split('\n');
        const lh = 16;
        const baseY = n.y + n.h*0.5 - (lines.length-1)*lh*0.5;
        for (let i=0; i<lines.length; i++){
          ctx.fillText(lines[i], n.x + n.w*0.5, baseY + i*lh);
        }
      }

      // role label
      if (n.key !== 'dram'){
        ctx.fillStyle = 'rgba(233,233,243,.80)';
        ctx.font = '600 11px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
        ctx.textBaseline = 'top';
        ctx.fillText(n.key === 'cpu' ? 'executes load/store' : 'schedules DRAM commands', n.x + n.w*0.5, n.y + 8);
      }

      if (n.key === 'dram'){
        drawDramInside(n);
      }

      if (n.key === 'cpu'){
        drawCpuInside(n);
      }

      ctx.restore();
    }

    function drawCpuInside(n){
      const pad = 10;
      const headerH = 22;
      const x0 = n.x + pad;
      const y0 = n.y + headerH + 10;
      const w = n.w - pad*2;
      const h = n.h - headerH - 20;

      // Cache area
      const cacheH = Math.max(86, h * 0.62);
      const imcH = h - cacheH - 10;

      // L1 cache label
      ctx.save();
      ctx.fillStyle = 'rgba(233,233,243,.88)';
      ctx.font = '800 11px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('L1 cache (4 lines × 8 bytes)', x0, y0);

      const lines = state.cache.lines;
      const cols = state.cache.lineSize;
      const rows = state.cache.lineCount;
      const gridY = y0 + 18;
      const gridH = cacheH - 24;
      const cellW = w / cols;
      const cellH = gridH / rows;

      // draw cells
      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          const x = x0 + c*cellW;
          const y = gridY + r*cellH;
          const line = lines[r];

          ctx.fillStyle = 'rgba(255,255,255,.03)';
          roundRect(ctx, x+1, y+1, cellW-2, cellH-2, 6);
          ctx.fill();

          const isLastLine = (state.cache.last.lineIndex === r);
          const isLastByte = isLastLine && (state.cache.last.byteIndex === c);
          if (state.cache.last.flashT > 0 && isLastLine){
            const a = clamp(state.cache.last.flashT / 0.6, 0, 1);
            ctx.fillStyle = `rgba(124,209,255,${0.04 + a*0.10})`;
            roundRect(ctx, x+1, y+1, cellW-2, cellH-2, 6);
            ctx.fill();
          }
          if (isLastByte){
            ctx.fillStyle = (state.cache.last.op === 'store') ? 'rgba(122,255,143,.16)' : 'rgba(255,207,91,.14)';
            roundRect(ctx, x+1, y+1, cellW-2, cellH-2, 6);
            ctx.fill();
          }

          ctx.strokeStyle = 'rgba(255,255,255,.10)';
          roundRect(ctx, x+1, y+1, cellW-2, cellH-2, 6);
          ctx.stroke();

          const v = line.data[c];
          const txt = v.toString(16).toUpperCase().padStart(2,'0');
          ctx.fillStyle = 'rgba(233,233,243,.92)';
          ctx.font = '800 10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(txt, x + cellW*0.5, y + cellH*0.58);
        }

        // line meta (tag/valid/dirty)
        const line = lines[r];
        const metaX = x0;
        const metaY = gridY + r*cellH - 12;
        ctx.fillStyle = 'rgba(233,233,243,.70)';
        ctx.font = '700 10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(`L${r} ${line.valid ? ('tag=' + line.tag) : 'empty'}${line.dirty ? ' dirty' : ''}`, metaX, metaY);
      }

      // IMC block inside CPU
      const imcY = gridY + gridH + 12;
      const imc = { x: x0, y: imcY, w: w, h: Math.max(36, imcH) };
      ctx.fillStyle = 'rgba(255,255,255,.03)';
      ctx.strokeStyle = 'rgba(255,207,91,.18)';
      roundRect(ctx, imc.x, imc.y, imc.w, imc.h, 10);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,207,91,.92)';
      ctx.font = '900 11px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('IMC (Integrated Memory Controller)', imc.x + 10, imc.y + imc.h*0.5);

      ctx.restore();
    }

    function drawDramInside(n){
      const pad = 10;
      const headerH = 22;
      const sigH = 20;
      const x0 = n.x + pad;
      const y0 = n.y + headerH + 12;
      const w = n.w - pad*2;
      const h = Math.max(10, n.h - headerH - sigH - 18);

      const cols = 8;
      const rows = 4;
      const cellW = w / cols;
      const cellH = h / rows;

      // Mini grid
      const sig = state.sim.dramSig;
      ctx.save();
      for (let i=0; i<CONFIG.memBytes; i++){
        const r = Math.floor(i / cols);
        const c = i % cols;
        const x = x0 + c*cellW;
        const y = y0 + r*cellH;

        const isActiveAddr = (state.sim.lastAddr === i);
        const rr = Math.floor(i / cols);
        const cc = i % cols;
        const isActiveRow = (sig.row !== null && rr === sig.row);
        const isActiveCol = (sig.col !== null && cc === sig.col);

        // Base background for readability
        ctx.fillStyle = 'rgba(255,255,255,.06)';
        roundRect(ctx, x+1, y+1, cellW-2, cellH-2, 6);
        ctx.fill();

        if (sig.flashT > 0 && (isActiveRow || isActiveCol)){
          const a = clamp(sig.flashT / 0.45, 0, 1);
          ctx.fillStyle = isActiveRow ? `rgba(124,209,255,${0.08 + a*0.18})` : `rgba(255,207,91,${0.06 + a*0.16})`;
          roundRect(ctx, x+1, y+1, cellW-2, cellH-2, 6);
          ctx.fill();
        }

        if (isActiveAddr){
          ctx.fillStyle = (state.sim.lastOp === 'store') ? 'rgba(122,255,143,.18)' : 'rgba(124,209,255,.18)';
          roundRect(ctx, x+1, y+1, cellW-2, cellH-2, 6);
          ctx.fill();
        }

        ctx.strokeStyle = 'rgba(255,255,255,.14)';
        roundRect(ctx, x+1, y+1, cellW-2, cellH-2, 6);
        ctx.stroke();

        ctx.fillStyle = 'rgba(233,233,243,.95)';
        ctx.font = '800 11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const v = state.mem[i];
        const hex = v.toString(16).toUpperCase().padStart(2,'0');
        ctx.fillText(hex, x + cellW*0.5, y + cellH*0.55);
      }

      // Signals strip (dedicated area below the grid)
      const stripY = y0 + h + 10;
      ctx.fillStyle = 'rgba(0,0,0,.22)';
      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      roundRect(ctx, n.x + 8, stripY - 12, n.w - 16, 18, 10);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = 'rgba(233,233,243,.92)';
      ctx.font = '800 10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const ras = (sig.row === null) ? '—' : String(sig.row);
      const cas = (sig.col === null) ? '—' : String(sig.col);
      ctx.fillText(`RAS:${ras}  CAS:${cas}  CMD:${sig.cmd}`, n.x + 14, stripY - 3);

      ctx.restore();
    }

    function drawButton(b){
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,.06)';
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      roundRect(ctx, b.x, b.y, b.w, b.h, 14);
      ctx.fill();
      ctx.stroke();

      // icon
      const cx = b.x + b.w*0.5;
      const cy = b.y + b.h*0.40;
      drawIcon(b.icon || 'dot', cx, cy, 16);

      // label
      ctx.fillStyle = COLORS.text;
      ctx.font = '800 11px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.label, cx, b.y + b.h*0.80);
      ctx.restore();
    }

    function drawIcon(kind, x, y, s){
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(233,233,243,.85)';
      ctx.fillStyle = 'rgba(233,233,243,.85)';

      if (kind === 'play'){
        ctx.beginPath();
        ctx.moveTo(x - s*0.45, y - s*0.55);
        ctx.lineTo(x - s*0.45, y + s*0.55);
        ctx.lineTo(x + s*0.60, y);
        ctx.closePath();
        ctx.fill();
      } else if (kind === 'pause'){
        const w = s*0.22;
        const h = s*1.1;
        ctx.fillRect(x - w - s*0.12, y - h*0.5, w, h);
        ctx.fillRect(x + s*0.12, y - h*0.5, w, h);
      } else if (kind === 'step'){
        // bar + arrow
        ctx.beginPath();
        ctx.moveTo(x - s*0.60, y);
        ctx.lineTo(x + s*0.10, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + s*0.10, y - s*0.35);
        ctx.lineTo(x + s*0.60, y);
        ctx.lineTo(x + s*0.10, y + s*0.35);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x - s*0.72, y - s*0.55);
        ctx.lineTo(x - s*0.72, y + s*0.55);
        ctx.stroke();
      } else if (kind === 'reset'){
        // circular arrow
        const r = s*0.55;
        ctx.beginPath();
        ctx.arc(x, y, r, Math.PI*0.15, Math.PI*1.6);
        ctx.stroke();
        // arrow head
        const ax = x + r*Math.cos(Math.PI*0.15);
        const ay = y + r*Math.sin(Math.PI*0.15);
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax + s*0.35, ay - s*0.15);
        ctx.lineTo(ax + s*0.10, ay + s*0.28);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(x, y, s*0.18, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawArrow(from, to){
      const x0 = from.x + from.w;
      const y0 = from.y + from.h*0.5;
      const x1 = to.x;
      const y1 = to.y + to.h*0.5;
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x0 + 10, y0);
      ctx.lineTo(x1 - 10, y1);
      ctx.stroke();
      ctx.restore();
    }

    function drawPackets(dt){
      const speed = CONFIG.packetSpeed;
      const alive = [];
      for (const p of state.sim.packets){
        const dist = polyLen(p.pts);
        p.t = clamp(p.t + (speed * dt) / dist, 0, 1);
        const pos = pointOnPoly(p.pts, p.t);
        const x = pos.x;
        const y = pos.y;

        ctx.save();
        ctx.fillStyle = p.color || COLORS.accent;
        ctx.strokeStyle = 'rgba(0,0,0,.35)';
        ctx.lineWidth = 1;
        roundRect(ctx, x - 18, y - 10, 36, 20, 8);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = 'rgba(0,0,0,.75)';
        ctx.font = '700 10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(p.label).slice(0,8), x, y+0.5);
        ctx.restore();

        if (p.t < 1) alive.push(p);
      }
      state.sim.packets = alive;
    }

    function drawBoard(){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.08)';
      // Fill the visible viewport even when the scene is translated
      ctx.fillRect(-state.scene.ox, -state.scene.oy, state.w, state.h);
      const bus = state.layout.bus;
      if (bus){
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = 'rgba(124,209,255,.12)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(bus.x0, bus.y);
        ctx.lineTo(bus.x1, bus.y);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(255,207,91,.10)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(bus.x0, bus.y);
        ctx.lineTo(bus.x1, bus.y);
        ctx.stroke();
      }
      ctx.restore();
    }


    function drawMenu(){
      if (!state.ui.menuOpen) return;
      const M = state.layout.menu;
      ctx.save();

      // opaque overlay + opaque panel (no background mixing)
      ctx.fillStyle = 'rgba(0,0,0,.85)';
      ctx.fillRect(0,0,state.w,state.h);

      ctx.fillStyle = 'rgb(10,10,16)';
      ctx.strokeStyle = COLORS.stroke;
      roundRect(ctx, M.x, M.y, M.w, M.h, 16);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = COLORS.text;
      ctx.font = '700 14px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('CPU operation', M.x + 14, M.y + 14);

      const btn = (key, x, y, w, h, label, active=false) => {
        const r = { x, y, w, h, key };
        ctx.fillStyle = active ? 'rgba(124,209,255,.18)' : 'rgba(255,255,255,.06)';
        ctx.strokeStyle = active ? 'rgba(124,209,255,.45)' : COLORS.stroke;
        roundRect(ctx, x, y, w, h, 12);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = COLORS.text;
        ctx.font = '700 12px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x + w*0.5, y + h*0.5);
        return r;
      };

      const hit = [];
      const top = M.y + 44;
      hit.push(btn('op_load', M.x + 14, top, (M.w-34)/2, 32, 'LOAD', state.ui.op === 'load'));
      hit.push(btn('op_store', M.x + 20 + (M.w-34)/2, top, (M.w-34)/2, 32, 'STORE', state.ui.op === 'store'));

      ctx.fillStyle = COLORS.muted;
      ctx.font = '12px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Address (byte)', M.x + 14, top + 48);

      const rowY = top + 68;
      const smallW = 42;
      hit.push(btn('addr_dec', M.x + 14, rowY, smallW, 32, '−'));
      hit.push(btn('addr_inc', M.x + M.w - 14 - smallW, rowY, smallW, 32, '+'));
      ctx.fillStyle = COLORS.text;
      ctx.font = '700 16px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(state.ui.addr), M.x + M.w*0.5, rowY + 16);

      ctx.fillStyle = COLORS.muted;
      ctx.font = '12px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Value (0..255)', M.x + 14, rowY + 46);

      const valY = rowY + 66;
      hit.push(btn('val_dec', M.x + 14, valY, smallW, 32, '−'));
      hit.push(btn('val_inc', M.x + M.w - 14 - smallW, valY, smallW, 32, '+'));
      ctx.fillStyle = COLORS.text;
      ctx.font = '700 16px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const valLabel = (state.ui.op === 'store') ? String(state.ui.value) : '—';
      ctx.fillText(valLabel, M.x + M.w*0.5, valY + 16);

      const botY = M.y + M.h - 46;
      hit.push(btn('menu_close', M.x + 14, botY, 110, 32, 'Close'));
      hit.push(btn('menu_queue', M.x + M.w - 14 - 140, botY, 140, 32, 'Queue', false));

      state.layout.menuHits = hit;
      ctx.restore();
    }

    function draw(dt){
      ctx.clearRect(0,0,state.w,state.h);

      ctx.save();
      ctx.translate(state.scene.ox, state.scene.oy);

      drawBoard();

      const { cpu, dram } = state.layout.nodes;
      drawArrow(cpu, dram);

      drawNode(cpu, COLORS.cpu);
      drawNode(dram, COLORS.dram);

      // current operation preview under CPU
      ctx.save();
      ctx.fillStyle = COLORS.muted;
      ctx.font = '12px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const opLine = `op: ${state.ui.op.toUpperCase()}  addr: ${state.ui.addr}` + (state.ui.op==='store' ? (`  value: ${state.ui.value}`) : '');
      ctx.fillText(opLine, cpu.x + cpu.w*0.5, cpu.y + cpu.h + 4);
      ctx.restore();

      // buttons
      state.layout.buttons.play.label = state.sim.running ? 'Pause' : 'Play';
      drawButton(state.layout.buttons.step);
      drawButton(state.layout.buttons.play);
      drawButton(state.layout.buttons.reset);

      drawPackets(dt);
      drawMenu();

      ctx.restore();
    }

    function canvasPos(e){
      const r = canvas.getBoundingClientRect();
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    function onClick(px, py){
      const world = toWorld(px, py);
      const wx = world.x;
      const wy = world.y;
      // menu interactions have priority
      if (state.ui.menuOpen && state.layout.menuHits){
        for (const h of state.layout.menuHits){
          if (hitRect(wx, wy, h)){
            if (h.key === 'menu_close') state.ui.menuOpen = false;
            else if (h.key === 'menu_queue'){
              queueCpuScenario();
              state.ui.menuOpen = false;
            }
            else if (h.key === 'op_load') state.ui.op = 'load';
            else if (h.key === 'op_store') state.ui.op = 'store';
            else if (h.key === 'addr_dec') state.ui.addr = clamp(state.ui.addr - 1, 0, CONFIG.memBytes - 1);
            else if (h.key === 'addr_inc') state.ui.addr = clamp(state.ui.addr + 1, 0, CONFIG.memBytes - 1);
            else if (h.key === 'val_dec') state.ui.value = clamp(state.ui.value - 1, 0, 255);
            else if (h.key === 'val_inc') state.ui.value = clamp(state.ui.value + 1, 0, 255);
            return;
          }
        }
        // click outside menu closes
        const M = state.layout.menu;
        if (!hitRect(wx, wy, M)) state.ui.menuOpen = false;
        return;
      }

      const { cpu } = state.layout.nodes;
      const btns = state.layout.buttons;

      if (hitRect(wx, wy, cpu)){
        state.ui.menuOpen = true;
        return;
      }
      if (hitRect(wx, wy, btns.reset)){
        state.mem = new Uint8Array(CONFIG.memBytes);
        clearSim();
        return;
      }
      if (hitRect(wx, wy, btns.step)){
        doStep();
        return;
      }
      if (hitRect(wx, wy, btns.play)){
        state.sim.running = !state.sim.running;
        return;
      }
    }

    function bind(){
      window.addEventListener('resize', () => resize(), { passive: true });

      canvas.addEventListener('mousemove', (e) => {
        const p = canvasPos(e);
        state.pointer.x = p.x;
        state.pointer.y = p.y;
      });

      canvas.addEventListener('mousedown', (e) => {
        state.pointer.down = true;
        const p = canvasPos(e);
        state.scene.click.x = p.x;
        state.scene.click.y = p.y;
        state.scene.click.moved = false;

        const world = toWorld(p.x, p.y);
        const wx = world.x;
        const wy = world.y;

        // if menu open, don't start drag on background
        if (state.ui.menuOpen) return;

        // drag node if hit
        const nodes = state.layout.nodes;
        for (const key of ['cpu','dram']){
          const n = nodes[key];
          if (hitRect(wx, wy, n)){
            state.scene.drag = { kind: 'node', key, dx: wx - n.x, dy: wy - n.y };
            return;
          }
        }

        // otherwise pan scene
        state.scene.drag = { kind: 'pan', sx: p.x, sy: p.y, ox: state.scene.ox, oy: state.scene.oy };
      });

      canvas.addEventListener('mousemove', (e) => {
        const p = canvasPos(e);
        state.pointer.x = p.x;
        state.pointer.y = p.y;
        if (!state.pointer.down || !state.scene.drag) return;

        const dx = p.x - state.scene.click.x;
        const dy = p.y - state.scene.click.y;
        if (!state.scene.click.moved && (Math.abs(dx) + Math.abs(dy) > 4)) state.scene.click.moved = true;

        if (state.scene.drag.kind === 'pan'){
          state.scene.ox = state.scene.drag.ox + (p.x - state.scene.drag.sx);
          state.scene.oy = state.scene.drag.oy + (p.y - state.scene.drag.sy);
          return;
        }

        if (state.scene.drag.kind === 'node'){
          const world = toWorld(p.x, p.y);
          const wx = world.x;
          const wy = world.y;
          const key = state.scene.drag.key;
          if (!state.scene.nodes) state.scene.nodes = {};
          if (!state.scene.nodes[key]) state.scene.nodes[key] = {x:0,y:0};
          state.scene.nodes[key].x = wx - state.scene.drag.dx;
          state.scene.nodes[key].y = wy - state.scene.drag.dy;
          // recompute dependent layout pieces (buttons/menu/bus)
          layout();
        }
      });

      window.addEventListener('mouseup', (e) => {
        if (!state.pointer.down) return;
        state.pointer.down = false;
        const wasDrag = !!state.scene.drag;
        state.scene.drag = null;
        if (!wasDrag) return;
        if (state.scene.click.moved) return;
        // treat as click
        const p = canvasPos(e);
        onClick(p.x, p.y);
      });

      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space'){
          e.preventDefault();
          state.sim.running = !state.sim.running;
        }
        if (e.code === 'KeyS'){
          e.preventDefault();
          doStep();
        }
        if (e.code === 'Escape'){
          state.ui.menuOpen = false;
        }
        if (e.code === 'KeyC'){
          // Center scene
          state.scene.ox = 0;
          state.scene.oy = 0;
        }
      });
    }

    function tick(now){
      const t = now * 0.001;
      const dt = clamp(t - state.t, 0, 0.05);
      state.t = t;

      if (state.sim.dramSig && state.sim.dramSig.flashT > 0){
        state.sim.dramSig.flashT = Math.max(0, state.sim.dramSig.flashT - dt);
      }

      if (state.cache && state.cache.last && state.cache.last.flashT > 0){
        state.cache.last.flashT = Math.max(0, state.cache.last.flashT - dt);
      }

      if (state.sim.running){
        if (performance.now() >= state.sim.nextStepAt){
          if (!state.sim.queue.length){
            // If there is nothing queued, do nothing. User must Queue from CPU menu.
          } else {
            doStep();
          }
          state.sim.nextStepAt = performance.now() + CONFIG.stepMs;
        }
      }

      draw(dt);
      requestAnimationFrame(tick);
    }

    bind();
    resize();
    clearSim();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
