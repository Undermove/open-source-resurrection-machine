<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Team Health Check (Spotify model) — CSV export</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,100..900;1,9..144,100..900&family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap" rel="stylesheet" />
  <style>
    /* ===== RESET ===== */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* ===== CUSTOM PROPERTIES ===== */
    :root {
      --bg: #FAF6F1;
      --text: #2D2319;
      --accent: #C4593A;
      --ok: #5A8A58;
      --warn: #C9963A;
      --bad: #BE4D3A;
      --card: #FFFFFF;
      --card-shadow: 0 8px 32px rgba(45,35,25,0.08);
      --radius: 18px;
      --radius-sm: 12px;
      --muted: rgba(45,35,25,0.55);
      --stroke: rgba(45,35,25,0.10);
    }

    /* ===== CANVAS GRAIN (inline SVG filter) ===== */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      z-index: 9999;
      pointer-events: none;
      opacity: 0.028;
      background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='300'%3E%3Cfilter id='g'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23g)'/%3E%3C/svg%3E");
      background-repeat: repeat;
    }

    /* ===== BASE TYPOGRAPHY & BODY ===== */
    html, body {
      min-height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      font-size: 15px;
      line-height: 1.55;
    }

    body {
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
    }

    h1, h2, h3, h4, h5, h6 {
      font-family: 'Fraunces', Georgia, 'Times New Roman', serif;
      font-weight: 700;
      line-height: 1.25;
    }

    a {
      color: var(--accent);
      text-decoration: underline;
      text-underline-offset: 2px;
    }
    a:hover {
      text-decoration-thickness: 2px;
    }
    a:focus-visible {
      outline: 2px dashed var(--accent);
      outline-offset: 3px;
    }

    /* ===== SCREEN READER ONLY ===== */
    .sr {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }

    /* ===== SKIP LINK ===== */
    .skip {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateY(-120%);
      padding: 10px 14px;
      background: var(--text);
      color: var(--bg);
      border-radius: 0 0 var(--radius-sm) 0;
      font-weight: 600;
      z-index: 50;
      text-decoration: none;
    }
    .skip:focus {
      transform: translateY(0);
    }

    /* ===== HEADER ===== */
    header {
      padding: 16px clamp(16px, 4vw, 32px);
      border-bottom: 1px solid var(--stroke);
      background: rgba(250,246,241,0.88);
      backdrop-filter: blur(12px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header .row {
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      max-width: 1100px;
      margin: 0 auto;
    }
    header h1 {
      font-size: clamp(18px, 2.4vw, 26px);
      font-optical-sizing: auto;
      letter-spacing: -0.01em;
    }

    /* Mode toggle (center pills) */
    .modeToggle {
      display: inline-flex;
      gap: 0;
      padding: 4px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.6);
    }
    .modeBtn {
      border-radius: 999px;
      padding: 7px 16px;
      border: none;
      background: transparent;
      color: var(--text);
      font: inherit;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      line-height: 1;
      white-space: nowrap;
      transition: background 0.15s, box-shadow 0.15s;
    }
    .modeBtn[aria-pressed="true"] {
      background: var(--card);
      box-shadow: 0 2px 8px rgba(45,35,25,0.10);
    }
    .modeBtn:focus-visible {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }

    /* Language toggle (right) */
    .langToggle {
      display: inline-flex;
      gap: 4px;
      padding: 4px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.6);
    }
    .langBtn {
      border-radius: 999px;
      padding: 7px 10px;
      border: none;
      background: transparent;
      color: var(--text);
      font: inherit;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      line-height: 1;
      white-space: nowrap;
      transition: background 0.15s, box-shadow 0.15s;
    }
    .langBtn[aria-pressed="true"] {
      background: var(--card);
      box-shadow: 0 2px 8px rgba(45,35,25,0.10);
    }
    .langBtn:focus-visible {
      outline: 2px dashed var(--accent);
      outline-offset: 2px;
    }

    /* ===== MAIN ===== */
    main#main {
      flex: 1 1 auto;
      padding: 24px clamp(16px, 4vw, 32px) 40px;
    }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
    }

    /* ===== SCREEN VISIBILITY ===== */
    .screen {
      display: none;
    }
    .screen.active {
      display: block;
    }

    /* ===== FOOTER ===== */
    footer {
      padding: 16px clamp(16px, 4vw, 32px) 24px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
      border-top: 1px solid var(--stroke);
    }
    footer .wrap {
      max-width: 1100px;
      margin: 0 auto;
    }
    footer .row {
      display: flex;
      gap: 16px;
      align-items: baseline;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    footer a {
      color: var(--accent);
      text-decoration: underline;
    }
    footer a:hover {
      text-decoration-thickness: 2px;
    }

    /* ===== REDUCED MOTION ===== */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>
<body>
  <a class="skip" id="skipLink" href="#main">Skip to content</a>

  <header>
    <div class="row">
      <h1 id="appTitle">Team Health Check</h1>
      <div class="modeToggle" role="group" aria-label="Mode">
        <button id="modeSession" class="modeBtn" type="button" aria-pressed="true">Run Session</button>
        <button id="modeCompare" class="modeBtn" type="button" aria-pressed="false">Compare Teams</button>
      </div>
      <div class="langToggle" role="group" aria-label="Language">
        <button id="langEn" class="langBtn" type="button" aria-pressed="false">EN</button>
        <button id="langRu" class="langBtn" type="button" aria-pressed="true">RU</button>
      </div>
    </div>
  </header>

  <main id="main">
    <div class="wrap">
      <div id="setupScreen" class="screen active"></div>
      <div id="cardScreen" class="screen"></div>
      <div id="resultsScreen" class="screen"></div>
      <div id="compareScreen" class="screen"></div>
    </div>
  </main>

  <footer>
    <div class="wrap">
      <div class="row">
        <div id="footerLeft">
          Based on Spotify Engineering:
          <a id="spotifyLink" href="https://engineering.atspotify.com/2014/09/squad-health-check-model" target="_blank" rel="noopener noreferrer">Squad Health Check model</a>.
          <div id="telegramCredit" style="margin-top:6px;"></div>
        </div>
        <div>
          <a id="otherProjectsLink" href="index.html">View other projects</a>
        </div>
      </div>
    </div>
  </footer>

  <script>
    (() => {
      // ===== CONSTANTS =====
      const LANG_KEY = 'teamHealthCheck_lang_v1';
      const STORAGE_KEY = 'teamHealthCheck_v2';
      const OLD_STORAGE_KEY = 'teamHealthCheck_matrix_v1';
      const LEGACY_STORAGE_KEY = 'teamHealthCheck_v1';

      // ===== I18N DICTIONARY =====
      const I18N = {
        ru: {
          langLabel: 'Язык',
          tabsChecklist: 'Чек-лист',
          tabsSummary: 'Сводка по файлам',
          tourBtn: 'Как пользоваться?',
          pageTitle: 'Team Health Check — экспорт CSV',
          sessionTitle: 'Сессия',
          exportCsv: 'Скачать CSV',
          reset: 'Сбросить',
          resetConfirm: 'Сбросить форму и локально сохранённое состояние?',
          resetDone: 'Сброшено',
          teamLabel: 'Команда',
          dateLabel: 'Дата',
          facilitatorLabel: 'Фасилитатор / Автор',
          summaryPanelAria: 'Сводка по нескольким командам',
          clear: 'Очистить',
          exportSummary: 'Скачать CSV (сводка)',
          dropTitle: 'Перетащи CSV-файлы сюда',
          dropHint: 'или нажми, чтобы выбрать несколько файлов хелсчеков команд',
          summaryTableAria: 'Сводная таблица по файлам',
          checklistPanelAria: 'Матрица Health Check',
          checklistRegionAria: 'Матрица Team Health Check',
          checklistTitle: 'Squad Health Checklist',
          participant: 'Участник',
          participantName: 'Имя',
          participantNameLabel: 'Имя участника',
          removeParticipant: 'Удалить участника',
          addParticipant: 'Добавить участника',
          statusAria: 'статус',
          trendAria: 'тренд',
          trendNone: '—',
          trendUp: '↗ Улучшается',
          trendStable: '→ Стабильно',
          trendDown: '↘ Ухудшается',
          note: 'Заметка',
          green: 'Зелёный',
          yellow: 'Жёлтый',
          red: 'Красный',
          greenPrefix: 'Зеленый',
          redPrefix: 'Красный',
          autosaveSaving: 'Сохранение...',
          autosaveSavedAt: (t) => `Сохранено локально в ${t}`,
          autosaveFailed: 'Не удалось сохранить в localStorage',
          loaded: 'Загружено из localStorage',
          exportMissing: (n) => `Не заполнено состояние (зел/жёлт/красн) для ${n} индикаторов.\n\nПродолжить экспорт?`,
          deleteColConfirm: 'Удалить колонку? Данные в ней будут потеряны.',
          cantDeleteLast: 'Нельзя удалить последнюю колонку.',
          otherProjects: 'Посмотреть другие проекты',
          footerLeft: 'Модель сделана на основе Spotify Engineering:',
          telegramCreditHtml: 'Сделано для канала <a href="https://t.me/dimasshortposts" target="_blank" rel="noopener noreferrer">@dimasshortposts</a>',
          // New keys for redesign
          'setup.title': 'Настройка сессии',
          'setup.startSession': 'Начать сессию',
          'setup.addParticipant': 'Добавить',
          'setup.resumePrompt': 'Продолжить предыдущую сессию?',
          'setup.resumeYes': 'Продолжить',
          'setup.resumeNo': 'Начать заново',
          'card.healthy': 'Здорово',
          'card.unhealthy': 'Плохо',
          'card.prev': 'Назад',
          'card.next': 'Далее',
          'card.finish': 'Завершить',
          'card.notePlaceholder': 'Добавить заметку...',
          'results.title': 'Результаты',
          'results.overallNotes': 'Общие заметки',
          'results.overallNotesPlaceholder': 'Заметки фасилитатора...',
          'results.backToReview': 'Вернуться к обзору',
          'results.exportCsv': 'Скачать CSV',
          'mode.session': 'Сессия',
          'mode.compare': 'Сравнение команд',
          tour: {
            prev: 'Назад',
            next: 'Далее',
            done: 'Готово',
            step: (i, n) => `Шаг ${i} из ${n}`,
            steps: {
              tabsTitle: 'Вкладки',
              tabsBody: 'Здесь переключайся между чек-листом и сводкой по нескольким CSV.',
              teamTitle: 'Команда',
              teamBody: 'Введи название команды. Оно попадёт в CSV и в сводку.',
              dateTitle: 'Дата',
              dateBody: 'Выбери дату сессии. Удобно сравнивать несколько прогонов по датам.',
              facTitle: 'Фасилитатор',
              facBody: 'Укажи автора/фасилитатора (по желанию).',
              participantsTitle: 'Участники',
              participantsBody: 'Нажми плюс, чтобы добавить участника (колонку).',
              nameTitle: 'Имя участника',
              nameBody: 'Введи имя участника в заголовке его колонки.',
              cellTitle: 'Заполни ячейку',
              cellBody: 'Вместе с каждым участником команды выберите цвет и тренд по всем 10 пунктам.',
              exportTitle: 'Экспорт CSV',
              exportBody: 'Когда команда заполнит форму, скачай CSV.',
              summaryTitle: 'Сводка по файлам',
              summaryBody: 'Перейдём в сводку, чтобы сравнить несколько CSV между командами/датами.',
              dropTitle: 'Загрузка CSV',
              dropBody: 'Перетащи сюда несколько заполненных CSV команд (можно пачкой) или нажми и выбери файлы.'
            }
          }
        },
        en: {
          langLabel: 'Language',
          tabsChecklist: 'Checklist',
          tabsSummary: 'Multi-file summary',
          tourBtn: 'How to use?',
          pageTitle: 'Team Health Check — CSV export',
          sessionTitle: 'Session',
          exportCsv: 'Download CSV',
          reset: 'Reset',
          resetConfirm: 'Reset the form and locally saved state?',
          resetDone: 'Reset',
          teamLabel: 'Team',
          dateLabel: 'Date',
          facilitatorLabel: 'Facilitator / Author',
          summaryPanelAria: 'Multi-team summary',
          clear: 'Clear',
          exportSummary: 'Download CSV (summary)',
          dropTitle: 'Drop CSV files here',
          dropHint: 'or click to select multiple team healthcheck CSV files',
          summaryTableAria: 'Multi-file summary table',
          checklistPanelAria: 'Health Check matrix',
          checklistRegionAria: 'Team Health Check matrix',
          checklistTitle: 'Squad Health Checklist',
          participant: 'Participant',
          participantName: 'Name',
          participantNameLabel: 'Participant name',
          removeParticipant: 'Remove participant',
          addParticipant: 'Add participant',
          statusAria: 'status',
          trendAria: 'trend',
          trendNone: '—',
          trendUp: '↗ Improving',
          trendStable: '→ Stable',
          trendDown: '↘ Worsening',
          note: 'Note',
          green: 'Green',
          yellow: 'Yellow',
          red: 'Red',
          greenPrefix: 'Green',
          redPrefix: 'Red',
          autosaveSaving: 'Saving…',
          autosaveSavedAt: (t) => `Saved locally at ${t}`,
          autosaveFailed: 'Failed to save to localStorage',
          loaded: 'Loaded from localStorage',
          exportMissing: (n) => `Some cells have no status selected for ${n} criteria.\n\nExport anyway?`,
          deleteColConfirm: 'Delete this participant column? Data will be lost.',
          cantDeleteLast: 'You cannot delete the last column.',
          otherProjects: 'View other projects',
          footerLeft: 'Based on Spotify Engineering:',
          telegramCreditHtml: 'Made for the channel <a href="https://t.me/dimasshortposts" target="_blank" rel="noopener noreferrer">@dimasshortposts</a>',
          // New keys for redesign
          'setup.title': 'Session Setup',
          'setup.startSession': 'Start Session',
          'setup.addParticipant': 'Add',
          'setup.resumePrompt': 'Resume previous session?',
          'setup.resumeYes': 'Resume',
          'setup.resumeNo': 'Start fresh',
          'card.healthy': 'Healthy',
          'card.unhealthy': 'Unhealthy',
          'card.prev': 'Previous',
          'card.next': 'Next',
          'card.finish': 'Finish',
          'card.notePlaceholder': 'Add a note...',
          'results.title': 'Results',
          'results.overallNotes': 'Overall notes',
          'results.overallNotesPlaceholder': 'Facilitator notes...',
          'results.backToReview': 'Back to review',
          'results.exportCsv': 'Export CSV',
          'mode.session': 'Run Session',
          'mode.compare': 'Compare Teams',
          tour: {
            prev: 'Back',
            next: 'Next',
            done: 'Done',
            step: (i, n) => `Step ${i} of ${n}`,
            steps: {
              tabsTitle: 'Tabs',
              tabsBody: 'Switch between the checklist and the multi-file CSV summary here.',
              teamTitle: 'Team',
              teamBody: 'Enter the team name. It will be included in CSV and the summary.',
              dateTitle: 'Date',
              dateBody: 'Choose the session date to compare multiple runs over time.',
              facTitle: 'Facilitator',
              facBody: 'Optionally enter the facilitator/author.',
              participantsTitle: 'Participants',
              participantsBody: 'Click plus to add a participant (a column).',
              nameTitle: 'Participant name',
              nameBody: 'Enter the participant name in the column header.',
              cellTitle: 'Fill a cell',
              cellBody: 'Together with each team member, choose a color and a trend for all 10 items.',
              exportTitle: 'Export CSV',
              exportBody: 'When the team finishes the form, download the CSV.',
              summaryTitle: 'Multi-file summary',
              summaryBody: 'Switch to summary to compare multiple CSVs across teams/dates.',
              dropTitle: 'Upload CSV',
              dropBody: 'Drop multiple completed team CSV files here (batch is ok) or click to select files.'
            }
          }
        }
      };

      // ===== LANGUAGE FUNCTIONS =====
      function getLang() {
        try {
          const url = new URL(window.location.href);
          const fromUrl = url.searchParams.get('lang');
          if (fromUrl === 'en' || fromUrl === 'ru') return fromUrl;
        } catch(_) {}
        try {
          const saved = localStorage.getItem(LANG_KEY);
          if (saved === 'en' || saved === 'ru') return saved;
        } catch(_) {}
        return 'en';
      }

      let lang = getLang();

      function t(key) {
        const dict = I18N[lang] || I18N.ru;
        // Support dot notation for nested keys like 'tour.prev'
        // First try direct property (for keys like 'setup.title' stored as string keys)
        if (Object.prototype.hasOwnProperty.call(dict, key)) return dict[key];
        // Then try dot-path traversal (for nested objects like tour.prev)
        const parts = String(key).split('.');
        let cur = dict;
        for (const p of parts) {
          if (!cur || typeof cur !== 'object') return '';
          cur = cur[p];
        }
        return cur;
      }

      function setLang(next) {
        lang = next === 'en' ? 'en' : 'ru';
        try { localStorage.setItem(LANG_KEY, lang); } catch(_) {}

        try {
          const url = new URL(window.location.href);
          url.searchParams.set('lang', lang);
          window.history.replaceState({}, '', url);
        } catch(_) {}

        document.documentElement.lang = lang;

        const langRuBtn = document.getElementById('langRu');
        const langEnBtn = document.getElementById('langEn');
        if (langRuBtn) langRuBtn.setAttribute('aria-pressed', lang === 'ru' ? 'true' : 'false');
        if (langEnBtn) langEnBtn.setAttribute('aria-pressed', lang === 'en' ? 'true' : 'false');

        // Update mode toggle labels
        const modeSession = document.getElementById('modeSession');
        const modeCompare = document.getElementById('modeCompare');
        if (modeSession) modeSession.textContent = t('mode.session');
        if (modeCompare) modeCompare.textContent = t('mode.compare');

        // Update footer
        const footerLeft = document.getElementById('footerLeft');
        if (footerLeft) footerLeft.firstChild.nodeValue = `${t('footerLeft')} `;
        const telegramCredit = document.getElementById('telegramCredit');
        if (telegramCredit) telegramCredit.innerHTML = t('telegramCreditHtml');
        const otherProjectsLink = document.getElementById('otherProjectsLink');
        if (otherProjectsLink) otherProjectsLink.textContent = t('otherProjects');
      }

      function indTitle(ind) { return lang === 'en' ? (ind.titleEn || ind.title) : ind.title; }
      function indShort(ind) { return lang === 'en' ? (ind.shortEn || ind.short || indTitle(ind)) : (ind.short || indTitle(ind)); }
      function indAwesome(ind) { return lang === 'en' ? (ind.awesomeEn || ind.awesome) : ind.awesome; }
      function indCrappy(ind) { return lang === 'en' ? (ind.crappyEn || ind.crappy) : ind.crappy; }

      // ===== INDICATORS =====
      const indicators = [
        {
          id: 'value',
          title: 'Ценность',
          short: 'Ценность',
          awesome: 'Мы делаем именно то, что приносит пользу нашим клиентам и бизнесу.',
          crappy: 'Мы делаем работу, которая не несет никакой ценности или смысла.',
          titleEn: 'Value',
          shortEn: 'Value',
          awesomeEn: 'We build what brings value to our customers and the business.',
          crappyEn: 'We do work that brings no value or meaning.'
        },
        {
          id: 'easy_to_release',
          title: 'Простота релиза',
          short: 'Релиз',
          awesome: 'Релизы простые, частые и безболезненные, полностью автоматизированные.',
          crappy: 'Релизы — это ручной, болезненный процесс, который часто сопровождается проблемами.',
          titleEn: 'Easy to Release',
          shortEn: 'Release',
          awesomeEn: 'Releases are simple, frequent, painless and fully automated.',
          crappyEn: 'Releases are manual, painful and often come with problems.'
        },
        {
          id: 'fun',
          title: 'Веселье',
          short: 'Веселье',
          awesome: 'Мы с удовольствием приходим на работу и отлично проводим время.',
          crappy: 'Ужасная скука.',
          titleEn: 'Fun',
          shortEn: 'Fun',
          awesomeEn: 'We enjoy coming to work and have a great time.',
          crappyEn: 'Terribly boring.'
        },
        {
          id: 'tech_quality',
          title: 'Состояние кода',
          short: 'Код',
          awesome: 'Мы гордимся качеством нашего кода. Он чистый, понятный и легко тестируемый.',
          crappy: 'Код — это полная катастрофа, технический долг зашкаливает.',
          titleEn: 'Health of Codebase',
          shortEn: 'Code',
          awesomeEn: 'We are proud of our code quality. It is clean, clear and easy to test.',
          crappyEn: 'The codebase is a mess and technical debt is out of control.'
        },
        {
          id: 'learning',
          title: 'Обучение',
          short: 'Обучение',
          awesome: 'Мы постоянно учимся новому и интересному.',
          crappy: 'У нас нет времени или возможности учиться чему-то новому.',
          titleEn: 'Learning',
          shortEn: 'Learning',
          awesomeEn: 'We keep learning new and interesting things.',
          crappyEn: 'We have no time or opportunity to learn.'
        },
        {
          id: 'speed',
          title: 'Скорость',
          short: 'Скорость',
          awesome: 'Мы доставляем ценность быстро и вовремя.',
          crappy: 'Нам всегда не хватает времени. Процессы медленные и затянутые.',
          titleEn: 'Speed',
          shortEn: 'Speed',
          awesomeEn: 'We deliver value quickly and on time.',
          crappyEn: 'We are always short on time. Processes are slow and dragged out.'
        },
        {
          id: 'suitable_process',
          title: 'Подходящий процесс',
          short: 'Процесс',
          awesome: 'Процесс работы нам отлично подходит и помогает.',
          crappy: 'Процесс мешает работе или вообще отсутствует.',
          titleEn: 'Suitable Process',
          shortEn: 'Process',
          awesomeEn: 'Our process fits us well and helps us.',
          crappyEn: 'The process gets in the way or does not exist.'
        },
        {
          id: 'support',
          title: 'Поддержка',
          short: 'Поддержка',
          awesome: 'Мы всегда получаем отличную поддержку, когда она нам необходима.',
          crappy: 'Мы чувствуем себя брошенными на произвол судьбы.',
          titleEn: 'Support',
          shortEn: 'Support',
          awesomeEn: 'We get great support whenever we need it.',
          crappyEn: 'We feel left on our own.'
        },
        {
          id: 'pawns_or_players',
          title: 'Командная работа',
          short: 'Команда',
          awesome: 'Мы работаем как сплоченная команда и всегда помогаем друг другу.',
          crappy: 'Мы работаем как группа отдельных людей, а не как единое целое.',
          titleEn: 'Teamwork',
          shortEn: 'Team',
          awesomeEn: 'We work as a cohesive team and help each other.',
          crappyEn: 'We act as separate individuals, not as one team.'
        },
        {
          id: 'mission',
          title: 'Миссия',
          short: 'Миссия',
          awesome: 'Мы четко понимаем, зачем мы здесь и куда движемся.',
          crappy: 'У нас нет ясного понимания целей и общего видения будущего',
          titleEn: 'Mission',
          shortEn: 'Mission',
          awesomeEn: 'We clearly understand why we are here and where we are going.',
          crappyEn: 'We lack clear goals and a shared vision of the future.'
        }
      ];

      // ===== INDICATOR NAME LOOKUP =====
      const indicatorNameToId = (() => {
        const m = new Map();
        for (const ind of indicators) {
          const all = [
            ind.title,
            ind.short,
            ind.titleEn,
            ind.shortEn
          ].filter(Boolean);
          for (const v of all) {
            m.set(String(v).trim().toLowerCase(), ind.id);
          }
        }
        return m;
      })();

      function normalizeIndicatorToId(v) {
        const key = String(v || '').trim().toLowerCase();
        return indicatorNameToId.get(key) || null;
      }

      // ===== UTILITY FUNCTIONS =====
      function uid() {
        const rnd = Math.random().toString(16).slice(2);
        return `c_${Date.now().toString(16)}_${rnd}`;
      }

      function escapeCsvCell(v) {
        const s = v == null ? '' : String(v);
        if (/[",\n\r]/.test(s)) return `"${s.replaceAll('"', '""')}"`;
        return s;
      }

      function buildFilename(meta) {
        const date = meta.date || todayISO();
        const team = (meta.team || 'team').trim().replaceAll(/\s+/g, '_').replaceAll(/[^a-zA-Z0-9_\-а-яА-Я]/g, '');
        return `team-health-check_${team || 'team'}_${date}.csv`;
      }

      function todayISO() {
        const d = new Date();
        return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
      }

      function pad2(n) {
        const s = String(n);
        return s.length >= 2 ? s : `0${s}`;
      }

      function parseCsv(text) {
        const rows = [];
        let row = [];
        let cur = '';
        let inQ = false;
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          if (inQ) {
            if (ch === '"') {
              const next = text[i+1];
              if (next === '"') {
                cur += '"';
                i++;
              } else {
                inQ = false;
              }
            } else {
              cur += ch;
            }
            continue;
          }

          if (ch === '"') {
            inQ = true;
            continue;
          }
          if (ch === ',') {
            row.push(cur);
            cur = '';
            continue;
          }
          if (ch === '\n') {
            row.push(cur);
            cur = '';
            if (row.length > 1 || row.some((v) => v.trim() !== '')) rows.push(row);
            row = [];
            continue;
          }
          if (ch === '\r') continue;
          cur += ch;
        }
        row.push(cur);
        if (row.length > 1 || row.some((v) => v.trim() !== '')) rows.push(row);
        return rows;
      }

      function normalizeHeader(h) {
        return String(h || '').trim().toLowerCase();
      }

      function rowsToObjects(rows) {
        if (!rows || rows.length < 2) return [];
        const header = rows[0].map(normalizeHeader);
        const out = [];
        for (let i = 1; i < rows.length; i++) {
          const r = rows[i];
          const o = {};
          for (let j = 0; j < header.length; j++) {
            o[header[j]] = (r[j] == null) ? '' : String(r[j]);
          }
          out.push(o);
        }
        return out;
      }

      // ===== STATE =====
      let currentScreen = 'setup';
      let currentCardIndex = 0;

      let state = {
        global: { team: '', date: todayISO(), facilitator: '', overallNotes: '' },
        columns: [],
        data: {}
      };

      function blankColumn() {
        const id = uid();
        return {
          id,
          name: ''
        };
      }

      function ensureStateShape() {
        if (!state || typeof state !== 'object') state = { global: { team: '', date: todayISO(), facilitator: '', overallNotes: '' }, columns: [], data: {} };
        if (!state.global || typeof state.global !== 'object') state.global = { team: '', date: todayISO(), facilitator: '', overallNotes: '' };
        if (!Array.isArray(state.columns)) state.columns = [];
        if (!state.data || typeof state.data !== 'object') state.data = {};

        if (!state.columns.length) {
          state.columns = [blankColumn()];
        }
        for (const ind of indicators) {
          if (!state.data[ind.id] || typeof state.data[ind.id] !== 'object') state.data[ind.id] = {};
          for (const col of state.columns) {
            if (!state.data[ind.id][col.id] || typeof state.data[ind.id][col.id] !== 'object') {
              state.data[ind.id][col.id] = { status: '', trend: '', note: '' };
            }
          }
        }
      }

      function serialize() {
        return {
          global: state.global,
          columns: state.columns,
          data: state.data
        };
      }

      function applyState(saved) {
        const s = saved && typeof saved === 'object' ? saved : null;
        state = {
          global: (s && s.global && typeof s.global === 'object') ? s.global : { team: '', date: todayISO(), facilitator: '', overallNotes: '' },
          columns: (s && Array.isArray(s.columns)) ? s.columns : [],
          data: (s && s.data && typeof s.data === 'object') ? s.data : {}
        };
        ensureStateShape();
      }

      // ===== AUTOSAVE =====
      let autosaveTimer = null;

      function scheduleAutosave() {
        if (autosaveTimer) window.clearTimeout(autosaveTimer);
        autosaveTimer = window.setTimeout(() => {
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(serialize()));
          } catch(_) {}
        }, 250);
      }

      // ===== CSV EXPORT =====
      function validateForExport() {
        const invalid = [];
        for (const ind of indicators) {
          for (const col of state.columns) {
            const cellData = (state.data[ind.id] && state.data[ind.id][col.id]) ? state.data[ind.id][col.id] : {};
            if (!cellData.status) invalid.push(`${indTitle(ind)} / ${col.name || t('participant')}`);
          }
        }
        return invalid;
      }

      function exportCsv() {
        const global = state.global;
        const missing = validateForExport();

        if (missing.length) {
          const msg = t('exportMissing');
          const msgText = typeof msg === 'function' ? msg(missing.length) : '';
          if (!window.confirm(msgText)) return;
        }

        const header = ['participant_id','participant_name','team','date','facilitator','indicator','status','trend','note','overall_notes'];
        const rows = [header];

        for (const ind of indicators) {
          for (const col of state.columns) {
            const cellData = (state.data[ind.id] && state.data[ind.id][col.id]) ? state.data[ind.id][col.id] : {};
            rows.push([
              col.id,
              col.name || '',
              global.team || '',
              global.date || '',
              global.facilitator || '',
              indTitle(ind),
              cellData.status || '',
              cellData.trend || '',
              cellData.note || '',
              global.overallNotes || ''
            ]);
          }
        }

        const csv = rows.map((r) => r.map(escapeCsvCell).join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = buildFilename({ team: global.team || 'team', date: global.date || todayISO() });
        a.className = 'sr';
        a.textContent = 'download';
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.setTimeout(() => URL.revokeObjectURL(url), 0);
      }

      // ===== MIGRATIONS =====
      function migrateLegacyIfNeeded() {
        let hasNew = false;
        try { hasNew = !!localStorage.getItem(OLD_STORAGE_KEY); } catch(_) { hasNew = false; }
        if (hasNew) return;

        let legacyRaw = null;
        try { legacyRaw = localStorage.getItem(LEGACY_STORAGE_KEY); } catch(_) { legacyRaw = null; }
        if (!legacyRaw) return;

        try {
          const legacy = JSON.parse(legacyRaw);
          const meta = legacy && legacy.meta && typeof legacy.meta === 'object' ? legacy.meta : {};
          const col = blankColumn();
          col.name = t('participant');

          const data = {};
          for (const ind of indicators) {
            const v = legacy && legacy.data && legacy.data[ind.id] ? legacy.data[ind.id] : { status: '', trend: '', note: '' };
            data[ind.id] = { [col.id]: { status: v.status || '', trend: v.trend || '', note: v.note || '' } };
          }

          const migrated = {
            global: {
              team: typeof meta.team === 'string' ? meta.team : '',
              date: typeof meta.date === 'string' ? meta.date : todayISO(),
              facilitator: typeof meta.facilitator === 'string' ? meta.facilitator : '',
              overallNotes: typeof meta.overallNotes === 'string' ? meta.overallNotes : ''
            },
            columns: [col],
            data
          };
          try { localStorage.setItem(OLD_STORAGE_KEY, JSON.stringify(migrated)); } catch(_) {}
        } catch(_) {}
      }

      function migrateMatrixToParticipantsIfNeeded() {
        let raw = null;
        try { raw = localStorage.getItem(OLD_STORAGE_KEY); } catch(_) { raw = null; }
        if (!raw) return;

        try {
          const saved = JSON.parse(raw);
          const cols = saved && Array.isArray(saved.columns) ? saved.columns : null;
          const global = saved && saved.global && typeof saved.global === 'object' ? saved.global : null;
          const isOldMatrix = !!cols && cols.length && (Object.prototype.hasOwnProperty.call(cols[0], 'title') || Object.prototype.hasOwnProperty.call(cols[0], 'team'));
          if (!isOldMatrix) return;

          const newGlobal = {
            team: (global && typeof global.team === 'string') ? global.team : '',
            date: (global && typeof global.date === 'string') ? global.date : todayISO(),
            facilitator: (global && typeof global.facilitator === 'string') ? global.facilitator : '',
            overallNotes: (global && typeof global.overallNotes === 'string') ? global.overallNotes : ''
          };

          // Try to recover team/date/facilitator from the first old column
          const first = cols[0];
          if (first && typeof first === 'object') {
            if (!newGlobal.team && typeof first.team === 'string') newGlobal.team = first.team;
            if (typeof first.date === 'string') newGlobal.date = first.date;
            if (!newGlobal.facilitator && typeof first.facilitator === 'string') newGlobal.facilitator = first.facilitator;
          }

          const newCols = cols.map((c) => ({
            id: c.id,
            name: (typeof c.title === 'string' && c.title.trim()) ? c.title.trim() : (typeof c.name === 'string' ? c.name : '')
          }));

          const migrated = {
            global: newGlobal,
            columns: newCols,
            data: saved.data && typeof saved.data === 'object' ? saved.data : {}
          };
          localStorage.setItem(OLD_STORAGE_KEY, JSON.stringify(migrated));
        } catch(_) {}
      }

      // v1 -> v2 migration: copy data from old key to new key if new key doesn't exist
      function migrateV1toV2IfNeeded() {
        let hasV2 = false;
        try { hasV2 = !!localStorage.getItem(STORAGE_KEY); } catch(_) { hasV2 = false; }
        if (hasV2) return;

        let oldRaw = null;
        try { oldRaw = localStorage.getItem(OLD_STORAGE_KEY); } catch(_) { oldRaw = null; }
        if (!oldRaw) return;

        try {
          localStorage.setItem(STORAGE_KEY, oldRaw);
        } catch(_) {}
      }

      // ===== MULTI-FILE SUMMARY DATA LAYER =====
      let multiAgg = new Map();

      function getMultiBucket(team, date, indicator) {
        const tm = team || '—';
        const d = date || '—';
        const i = indicator || '—';
        const key = `${tm}__${d}__${i}`;
        const prev = multiAgg.get(key) || { team: tm, date: d, indicator: i, green: 0, yellow: 0, red: 0, trendCounts: { up: 0, stable: 0, down: 0 }, responses: 0, votes: [] };
        multiAgg.set(key, prev);
        return prev;
      }

      function addParticipantExport(objects) {
        for (const o of objects) {
          const team = (o.team || '').trim() || '—';
          const date = (o.date || '').trim() || '—';
          const indicator = (o.indicator || '').trim();
          const indicatorId = normalizeIndicatorToId(indicator) || indicator;
          const status = (o.status || '').trim().toLowerCase();
          const trend = (o.trend || '').trim();
          const participantName = (o.participant_name || '').trim();
          const participantId = (o.participant_id || '').trim();
          const note = (o.note || '').trim();
          const prev = getMultiBucket(team, date, indicatorId);
          if (status === 'green') prev.green++;
          if (status === 'yellow') prev.yellow++;
          if (status === 'red') prev.red++;
          if (trend && Object.prototype.hasOwnProperty.call(prev.trendCounts, trend)) prev.trendCounts[trend]++;
          prev.responses++;
          if (Array.isArray(prev.votes)) {
            prev.votes.push({
              participantId,
              participantName,
              status,
              trend,
              note
            });
          }
        }
      }

      function addSummaryExport(objects) {
        for (const o of objects) {
          const team = (o.team || '').trim() || '—';
          const date = (o.date || '').trim() || '—';
          const indicator = (o.indicator || '').trim() || '—';
          const indicatorId = normalizeIndicatorToId(indicator) || indicator;
          const prev = getMultiBucket(team, date, indicatorId);

          const green = Number(o.green || 0) || 0;
          const yellow = Number(o.yellow || 0) || 0;
          const red = Number(o.red || 0) || 0;
          const responses = green + yellow + red;

          prev.green += green;
          prev.yellow += yellow;
          prev.red += red;
          prev.responses += responses;

          const tr = (o.trend || '').trim();
          if (tr.includes('↗')) prev.trendCounts.up++;
          if (tr.includes('→')) prev.trendCounts.stable++;
          if (tr.includes('↘')) prev.trendCounts.down++;
        }
      }

      function pickLatestDatePerTeam() {
        const m = new Map();
        for (const b of multiAgg.values()) {
          const team = b.team || '—';
          const date = b.date || '—';
          if (m.has(team)) {
            const prev = m.get(team);
            if (prev < date) m.set(team, date);
          } else {
            m.set(team, date);
          }
        }
        return m;
      }

      function getBucket(team, date, indicator) {
        const tm = (team || '—');
        const d = (date || '—');
        const i = (indicator || '—');
        return multiAgg.get(`${tm}__${d}__${i}`) || null;
      }

      function worstStatus(bucket) {
        if (!bucket) return '';
        if ((bucket.red || 0) > 0) return 'red';
        if ((bucket.yellow || 0) > 0) return 'yellow';
        if ((bucket.green || 0) > 0) return 'green';
        return '';
      }

      function worstTrendLabel(trendCounts) {
        if (!trendCounts || typeof trendCounts !== 'object') return t('trendNone');
        if ((trendCounts.down || 0) > 0) return t('trendDown');
        if ((trendCounts.stable || 0) > 0) return t('trendStable');
        if ((trendCounts.up || 0) > 0) return t('trendUp');
        return t('trendNone');
      }

      function dominantTrendLabel(trendCounts) {
        const entries = Object.entries(trendCounts);
        entries.sort((a, b) => b[1] - a[1]);
        const top = entries[0];
        if (!top || top[1] === 0) return t('trendNone');
        if (top[0] === 'up') return t('trendUp');
        if (top[0] === 'stable') return t('trendStable');
        if (top[0] === 'down') return t('trendDown');
        return t('trendNone');
      }

      function pickMajorityStatus(bucket) {
        if (!bucket) return '';
        const g = bucket.green || 0;
        const y = bucket.yellow || 0;
        const r = bucket.red || 0;
        const max = Math.max(g, y, r);
        if (max === 0) return '';
        if (g === max) return 'green';
        if (y === max) return 'yellow';
        return 'red';
      }

      function labelStatusRu(s) {
        if (s === 'green') return 'Зелёный';
        if (s === 'yellow') return 'Жёлтый';
        if (s === 'red') return 'Красный';
        return '—';
      }

      function labelStatusEn(s) {
        if (s === 'green') return 'Green';
        if (s === 'yellow') return 'Yellow';
        if (s === 'red') return 'Red';
        return '—';
      }

      function labelTrendRu(tr) {
        if (tr === 'up') return '↗ Улучшается';
        if (tr === 'stable') return '→ Стабильно';
        if (tr === 'down') return '↘ Ухудшается';
        if (typeof tr === 'string' && tr.includes('↗')) return '↗ Улучшается';
        if (typeof tr === 'string' && tr.includes('→')) return '→ Стабильно';
        if (typeof tr === 'string' && tr.includes('↘')) return '↘ Ухудшается';
        return '—';
      }

      function labelTrendEn(tr) {
        if (tr === 'up') return '↗ Improving';
        if (tr === 'stable') return '→ Stable';
        if (tr === 'down') return '↘ Worsening';
        if (typeof tr === 'string' && tr.includes('↗')) return '↗ Improving';
        if (typeof tr === 'string' && tr.includes('→')) return '→ Stable';
        if (typeof tr === 'string' && tr.includes('↘')) return '↘ Worsening';
        return '—';
      }

      function trendLabelToCode(v) {
        if (!v) return '';
        if (v === 'up' || v === 'stable' || v === 'down') return v;
        const s = String(v);
        if (s.includes('↗')) return 'up';
        if (s.includes('→')) return 'stable';
        if (s.includes('↘')) return 'down';
        return '';
      }

      function escapeAttr(s) {
        return String(s == null ? '' : s)
          .replaceAll('&', '&amp;')
          .replaceAll('"', '&quot;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;');
      }

      function exportMultiCsv() {
        const latest = pickLatestDatePerTeam();
        const teams = Array.from(latest.keys()).sort((a, b) => a.localeCompare(b));
        const header = ['team','date','indicator','status','trend','green','yellow','red','responses'];
        const rows = [header];

        for (const team of teams) {
          const date = latest.get(team);
          for (const ind of indicators) {
            const b = getBucket(team, date, ind.id);
            const status = worstStatus(b);
            const trend = b ? worstTrendLabel(b.trendCounts) : '';
            rows.push([
              team,
              date || '',
              indTitle(ind),
              status,
              trend,
              String(b ? b.green : 0),
              String(b ? b.yellow : 0),
              String(b ? b.red : 0),
              String(b ? b.responses : 0)
            ]);
          }
        }
        const csv = rows.map((r) => r.map(escapeCsvCell).join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `team-health-check_multi_summary_${todayISO()}.csv`;
        a.className = 'sr';
        a.textContent = 'download';
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.setTimeout(() => URL.revokeObjectURL(url), 0);
      }

      // ===== RUN MIGRATIONS =====
      migrateLegacyIfNeeded();
      migrateMatrixToParticipantsIfNeeded();
      migrateV1toV2IfNeeded();

      // ===== LOAD SAVED STATE =====
      const savedRaw = (() => {
        try { return localStorage.getItem(STORAGE_KEY); } catch(_) { return null; }
      })();
      if (savedRaw) {
        try {
          const saved = JSON.parse(savedRaw);
          applyState(saved);
        } catch(_) {
          applyState({ global: { team: '', date: todayISO(), facilitator: '', overallNotes: '' }, columns: [blankColumn()], data: {} });
        }
      } else {
        applyState({ global: { team: '', date: todayISO(), facilitator: '', overallNotes: '' }, columns: [blankColumn()], data: {} });
      }

      // ===== INIT LANGUAGE =====
      setLang(lang);

      // ===== BIND LANGUAGE TOGGLE =====
      const langRuBtn = document.getElementById('langRu');
      const langEnBtn = document.getElementById('langEn');
      if (langRuBtn) langRuBtn.addEventListener('click', () => setLang('ru'));
      if (langEnBtn) langEnBtn.addEventListener('click', () => setLang('en'));

    })();
  </script>
</body>
</html>
